<!DOCTYPE html>
<html lang="en">
<head>
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-020D2NVH9F"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-020D2NVH9F');
</script>
<meta charset="UTF-8">
<link rel="icon" type="image/png" href="favicon.png">
<link rel="apple-touch-icon" href="favicon.png">
<meta property="og:title" content="Games ‚Äî AIB College Basketball Ratings">
<meta property="og:description" content="College basketball rankings, bracketology, and analytics powered by AI Bracketology">
<meta property="og:image" content="https://ai-bracketology.github.io/cbb-rankings/docs/new_header.png">
<meta property="og:type" content="website">
<meta name="twitter:card" content="summary_large_image">
<meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
<meta http-equiv="Pragma" content="no-cache">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Games ‚Äî CBB Ratings 2025-26</title>
<script>
  (function(){
    var t = localStorage.getItem("cbb_theme");
    if (t === "light") document.documentElement.setAttribute("data-theme","light");
  })();
  /* reload when restored from bfcache (back/forward navigation) */
  window.addEventListener("pageshow", function(e) {
    if (e.persisted) window.location.reload();
  });
</script>
<style>
  :root {
    --bg:        #0d1117;
    --surface:   #161b22;
    --border:    #30363d;
    --text:      #c9d1d9;
    --text-dim:  #8b949e;
    --accent:    #58a6ff;
    --green:     #3fb950;
    --red:       #f85149;
  }
  html[data-theme="light"] {
    --bg:        #ffffff;
    --surface:   #f6f8fa;
    --border:    #d0d7de;
    --text:      #1f2328;
    --text-dim:  #656d76;
    --accent:    #0969da;
    --green:     #1a7f37;
    --red:       #cf222e;
  }
  * { box-sizing: border-box; margin: 0; padding: 0; }
  body {
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, Arial, sans-serif;
    background: var(--bg);
    color: var(--text);
    line-height: 1.5;
  }

  /* header */
  header {
    background: var(--surface);
    border-bottom: 1px solid var(--border);
    padding: 20px 32px;
    display: flex;
    align-items: center;
    gap: 16px;
  }
  header a.back {
    color: var(--accent);
    text-decoration: none;
    font-size: .85rem;
  }
  header a.back:hover { text-decoration: underline; }
  header h1 { font-size: 1.4rem; font-weight: 600; }
  header .game-count { color: var(--text-dim); font-size: .9rem; margin-left: auto; }

  /* theme toggle */
  .theme-toggle {
    background: var(--surface);
    border: 1px solid var(--border);
    color: var(--text);
    font-size: 1.1rem;
    padding: 5px 10px;
    border-radius: 6px;
    cursor: pointer;
    transition: border-color .15s;
    line-height: 1;
  }
  .theme-toggle:hover { border-color: var(--accent); }

  /* tabs */
  .tab-bar {
    max-width: 1400px;
    margin: 16px auto 0;
    padding: 0 20px;
    display: flex;
    gap: 4px;
    border-bottom: 2px solid var(--border);
  }
  .tab-bar button {
    background: transparent;
    border: none;
    color: var(--text-dim);
    padding: 10px 20px;
    font-size: .85rem;
    font-weight: 600;
    cursor: pointer;
    border-bottom: 2px solid transparent;
    margin-bottom: -2px;
    transition: color .15s, border-color .15s;
  }
  .tab-bar button:hover { color: var(--text); }
  .tab-bar button.active { color: var(--accent); border-bottom-color: var(--accent); }

  /* date nav */
  .date-nav {
    max-width: 1400px;
    margin: 16px auto 0;
    padding: 0 20px;
    display: flex;
    align-items: center;
    gap: 12px;
  }
  .date-nav button {
    background: var(--surface);
    border: 1px solid var(--border);
    border-radius: 6px;
    color: var(--text);
    padding: 6px 14px;
    font-size: .85rem;
    cursor: pointer;
    transition: border-color .15s;
  }
  .date-nav button:hover { border-color: var(--accent); color: var(--accent); }
  .date-nav .date-label {
    color: var(--text-dim);
    font-size: .85rem;
  }

  /* table */
  .table-wrap {
    max-width: 1400px;
    margin: 16px auto 40px;
    padding: 0 20px;
    overflow-x: auto;
  }
  table {
    width: 100%;
    border-collapse: collapse;
    font-size: .82rem;
  }
  thead { position: sticky; top: 0; z-index: 2; }
  thead th {
    background: var(--surface);
    border-bottom: 2px solid var(--border);
    color: var(--text-dim);
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: .03em;
    padding: 10px 8px;
    cursor: pointer;
    white-space: nowrap;
    user-select: none;
    text-align: center;
  }
  thead th:hover { color: var(--accent); }

  tbody tr { border-bottom: 1px solid var(--border); }
  tbody tr:hover { background: rgba(88,166,255,.06); }
  tbody td {
    padding: 8px 8px;
    white-space: nowrap;
    text-align: center;
  }

  .win  { color: var(--green); font-weight: 600; }
  .loss { color: var(--red); font-weight: 600; }
  .net-pos { color: var(--green); font-weight: 600; }
  .net-neg { color: var(--red); }
  .heatmap { border-radius: 4px; }

  footer {
    text-align: center;
    padding: 24px;
    color: var(--text-dim);
    font-size: .75rem;
    border-top: 1px solid var(--border);
  }
  footer a { color: var(--accent); text-decoration: none; }

  /* ---------- mobile responsive ---------- */
  @media (max-width: 768px) {
    header {
      flex-direction: column;
      align-items: flex-start;
      padding: 14px 16px;
      gap: 6px;
    }
    header h1 { font-size: 1.15rem; }
    header .game-count { margin-left: 0; font-size: .8rem; }

    .tab-bar {
      overflow-x: auto;
      -webkit-overflow-scrolling: touch;
      scrollbar-width: none;
      padding: 0 12px;
    }
    .tab-bar::-webkit-scrollbar { display: none; }
    .tab-bar button {
      padding: 8px 14px;
      font-size: .78rem;
      white-space: nowrap;
      flex-shrink: 0;
    }

    .date-nav {
      padding: 0 12px;
      flex-wrap: wrap;
      justify-content: center;
    }
    .date-nav button { padding: 5px 10px; font-size: .78rem; }

    .table-wrap {
      padding: 0 8px;
      -webkit-overflow-scrolling: touch;
    }
    table { font-size: .72rem; }
    thead th { padding: 7px 4px; font-size: .68rem; }
    tbody td { padding: 6px 4px; }
  }

  @media (max-width: 480px) {
    header h1 { font-size: 1rem; }
    .date-nav button { font-size: .72rem; padding: 4px 8px; }
    .date-nav .date-label { font-size: .78rem; }
  }
</style>
</head>
<body>

<header>
  <a href="index.html" class="back">‚Üê Rankings</a>
  <h1 id="dateTitle">Games</h1>
  <span class="game-count" id="gameCount"></span>
  <button class="theme-toggle" id="themeToggle" title="Toggle light/dark mode">üåô</button>
</header>

<div class="tab-bar">
  <button class="active" data-tab="daily">Daily Games</button>
  <button data-tab="upsets">Biggest Upsets</button>
</div>

<div id="dailyTab">
<div class="date-nav">
  <button id="prevDay">‚óÄ Prev Day</button>
  <span class="date-label" id="dateLabel"></span>
  <button id="nextDay">Next Day ‚ñ∂</button>
</div>

<div class="table-wrap" id="pastTableWrap">
  <table>
    <thead>
      <tr id="headerRow"></tr>
    </thead>
    <tbody id="tbody"></tbody>
  </table>
</div>

<div class="table-wrap" id="futureTableWrap" style="display:none">
  <table>
    <thead>
      <tr id="futureHeaderRow"></tr>
    </thead>
    <tbody id="futureTbody"></tbody>
  </table>
</div>
</div>

<div id="upsetsTab" style="display:none">
<div class="table-wrap">
  <table>
    <thead>
      <tr id="upsetsHeaderRow"></tr>
    </thead>
    <tbody id="upsetsTbody"></tbody>
  </table>
</div>
</div>

<footer>
  <p>Data via <a href="https://www.espn.com" target="_blank">ESPN</a>. Built by <a href="https://github.com/ai-bracketology" target="_blank">AI Bracketology</a>.</p>
</footer>

<script>
/* ---- theme toggle ---- */
(function initThemeToggle() {
  const btn = document.getElementById("themeToggle");
  const isLight = document.documentElement.getAttribute("data-theme") === "light";
  btn.textContent = isLight ? "‚òÄÔ∏è" : "üåô";
  btn.addEventListener("click", () => {
    const nowLight = document.documentElement.getAttribute("data-theme") === "light";
    if (nowLight) {
      document.documentElement.removeAttribute("data-theme");
      localStorage.setItem("cbb_theme", "dark");
      btn.textContent = "üåô";
    } else {
      document.documentElement.setAttribute("data-theme", "light");
      localStorage.setItem("cbb_theme", "light");
      btn.textContent = "‚òÄÔ∏è";
    }
  });
})();

const HOME_ADV = 3.0;  // points of home advantage for projected scores
const AVG_POSS = 68.9; // national average tempo for projected scores
const SCORE_SCALE = 1.10; // calibration: SRS efficiencies normalized to 100 underpredict by ~10%

const COLS = [
  { key: "winner_name",      label: "Winner",          fmt: v => v, align: "left" },
  { key: "loser_name",       label: "Loser",           fmt: v => v, align: "left" },
  { key: "score",            label: "Score",            fmt: v => v },
  { key: "winner_loc",       label: "Loc",              fmt: v => v },
  { key: "matchup_conf",     label: "Conf",             fmt: v => v, align: "left" },
  { key: "expected_margin",  label: "Projected Score",  fmt: v => v, align: "left" },
  { key: "upset_score",      label: "Upset Score",      fmt: v => v != null ? (v >= 0 ? "+" : "") + v.toFixed(1) : "‚Äì", cls: v => v != null ? (v > 0 ? "net-pos" : "net-neg") : "" },
  { key: "ball_score",       label: "Ball Score",       fmt: v => v != null ? v.toFixed(1) : "‚Äì", heat: "high" },
  { key: "bubble_impact",   label: "Bubble Impact",    fmt: v => v != null ? v.toFixed(1) : "‚Äì", heat: "high" },
];

const UPSET_COLS = [
  { key: "_rank",             label: "#",               fmt: v => v, align: "center" },
  { key: "date",              label: "Date",             fmt: v => v, align: "center" },
  { key: "winner_name",      label: "Winner",           fmt: v => v, align: "left" },
  { key: "loser_name",       label: "Loser",            fmt: v => v, align: "left" },
  { key: "score",            label: "Score",             fmt: v => v },
  { key: "winner_loc",       label: "Loc",               fmt: v => v },
  { key: "matchup_conf",     label: "Conf",              fmt: v => v, align: "left" },
  { key: "expected_margin",  label: "Projected Score",   fmt: v => v, align: "left" },
  { key: "upset_score",      label: "Upset Score",       fmt: v => v != null ? "+" + v.toFixed(1) : "‚Äì", cls: v => "net-pos" },
];

const FUTURE_COLS = [
  { key: "away_name",        label: "Away",              fmt: v => v, align: "left" },
  { key: "home_name",        label: "Home",              fmt: v => v, align: "left" },
  { key: "matchup_conf",     label: "Conf",              fmt: v => v, align: "left" },
  { key: "time",             label: "Time",              fmt: v => v || "‚Äì" },
  { key: "expected_result",  label: "Projected Score",   fmt: v => v, align: "left" },
  { key: "ball_score",       label: "Ball Score",        fmt: v => v != null ? v.toFixed(1) : "‚Äì", heat: "high" },
  { key: "bubble_impact",   label: "Bubble Impact",     fmt: v => v != null ? v.toFixed(1) : "‚Äì", heat: "high" },
];

let futureSortCol = "ball_score";
let futureSortAsc = false;

let ALL_GAMES = {};
let ALL_TEAMS = {};
let ALL_DATES = [];
let SCHED_BY_DATE = {};   // future games keyed by date
let SIM_BY_TEAM = {};     // sim results keyed by team_abbr ‚Üí { make_pct, ... }
let currentDate = "";
let activeTab = "daily";

let sortCol = "ball_score";
let sortAsc = false;

let upsetSortCol = "upset_score";
let upsetSortAsc = false;

const params = new URLSearchParams(window.location.search);
const dateParam = params.get("date");

/* ---- fetch data ---- */
Promise.all([
  fetch("games.json").then(r => r.json()),
  fetch("data.json").then(r => r.json()),
  fetch("schedule.json").then(r => r.json()).catch(() => ({})),
  fetch("sim_results.json").then(r => r.json()).catch(() => []),
]).then(([gamesData, teamsData, scheduleData, simData]) => {
  ALL_GAMES = gamesData;
  teamsData.forEach(t => { ALL_TEAMS[t.team_abbr] = t; });
  simData.forEach(s => { SIM_BY_TEAM[s.team_abbr] = s; });

  /* Build SCHED_BY_DATE: deduplicate (each game appears twice, once per team).
     Keep one row per matchup: the "home" team's entry, or alphabetically first for neutral. */
  const seenSched = new Set();
  Object.entries(scheduleData).forEach(([abbr, games]) => {
    if (abbr === "TBD") return;  // skip conference-tourney placeholders
    games.forEach(g => {
      if (g.opp_abbr === "TBD") return;
      // create a canonical key to deduplicate
      const pair = [abbr, g.opp_abbr].sort().join("|");
      const key = g.date + "|" + pair;
      if (seenSched.has(key)) return;
      seenSched.add(key);
      if (!SCHED_BY_DATE[g.date]) SCHED_BY_DATE[g.date] = [];
      SCHED_BY_DATE[g.date].push({ team_abbr: abbr, ...g });
    });
  });

  const dateSet = new Set();
  const playedDates = new Set();
  Object.values(ALL_GAMES).forEach(games => {
    games.forEach(g => { if (g.date) { dateSet.add(g.date); playedDates.add(g.date); } });
  });
  /* merge future dates from schedule */
  Object.keys(SCHED_BY_DATE).forEach(d => dateSet.add(d));
  ALL_DATES = [...dateSet].sort();

  /* default to latest played date (not future) unless a date param is given */
  const playedArr = [...playedDates].sort();
  currentDate = dateParam || playedArr[playedArr.length - 1] || ALL_DATES[ALL_DATES.length - 1] || "";
  buildHeader();
  buildFutureHeader();
  buildUpsetsHeader();
  renderDate();
}).catch(e => {
  document.getElementById("dateTitle").textContent = `Error: ${e}`;
});

/* ---- tab switching ---- */
document.querySelectorAll(".tab-bar button").forEach(btn => {
  btn.addEventListener("click", () => {
    document.querySelectorAll(".tab-bar button").forEach(b => b.classList.remove("active"));
    btn.classList.add("active");
    activeTab = btn.dataset.tab;
    gtag('event', 'tab_click', { event_category: 'navigation', event_label: activeTab, page: 'game_date' });
    document.getElementById("dailyTab").style.display = activeTab === "daily" ? "" : "none";
    document.getElementById("upsetsTab").style.display = activeTab === "upsets" ? "" : "none";
    if (activeTab === "daily") {
      renderDate();
    } else {
      document.getElementById("dateTitle").textContent = "Biggest Upsets";
      document.getElementById("gameCount").textContent = "";
      renderUpsets();
    }
  });
});

/* ---- date navigation ---- */
document.getElementById("prevDay").addEventListener("click", () => {
  const idx = ALL_DATES.indexOf(currentDate);
  if (idx > 0) { currentDate = ALL_DATES[idx - 1]; updateURL(); renderDate(); }
});
document.getElementById("nextDay").addEventListener("click", () => {
  const idx = ALL_DATES.indexOf(currentDate);
  if (idx < ALL_DATES.length - 1) { currentDate = ALL_DATES[idx + 1]; updateURL(); renderDate(); }
});

function updateURL() {
  const url = new URL(window.location);
  url.searchParams.set("date", currentDate);
  history.replaceState(null, "", url);
}

/* ---- bubble impact helper ---- */
// Returns 0-10 score: high when both teams are near the tournament bubble (make_pct ‚âà 50%)
function bubbleImpact(abbr1, abbr2) {
  const s1 = SIM_BY_TEAM[abbr1], s2 = SIM_BY_TEAM[abbr2];
  if (!s1 || !s2) return null;
  const prox1 = 1 - Math.abs((s1.make_pct || 0) - 50) / 50;
  const prox2 = 1 - Math.abs((s2.make_pct || 0) - 50) / 50;
  return ((prox1 + prox2) / 2) * 10;
}

/* ---- heatmap helper ---- */
function heatColor(val, min, max, invert) {
  if (val == null || min === max) return "";
  let t = (val - min) / (max - min);
  if (invert) t = 1 - t;
  const r = Math.round(13 + (88 - 13) * t);
  const g = Math.round(27 + (166 - 27) * t);
  const b = Math.round(42 + (255 - 42) * t);
  return `rgba(${r},${g},${b},0.25)`;
}

/* ---- build header ---- */
function buildHeader() {
  const tr = document.getElementById("headerRow");
  tr.innerHTML = "";
  COLS.forEach(c => {
    const th = document.createElement("th");
    th.textContent = c.label;
    th.style.textAlign = c.align || "center";
    th.addEventListener("click", () => {
      if (sortCol === c.key) sortAsc = !sortAsc;
      else { sortCol = c.key; sortAsc = false; }
      renderDate();
    });
    tr.appendChild(th);
  });
}

/* ---- render games for current date ---- */
function renderDate() {
  const d = new Date(currentDate + "T12:00:00");
  const formatted = d.toLocaleDateString("en-US", { weekday: "long", year: "numeric", month: "long", day: "numeric" });
  document.getElementById("dateTitle").textContent = formatted;
  document.getElementById("dateLabel").textContent = currentDate;
  document.title = `${formatted} ‚Äî CBB Games`;

  const idx = ALL_DATES.indexOf(currentDate);
  document.getElementById("prevDay").disabled = idx <= 0;
  document.getElementById("nextDay").disabled = idx >= ALL_DATES.length - 1;

  /* Check if this date has played games */
  let hasPlayed = false;
  Object.values(ALL_GAMES).forEach(games => {
    games.forEach(g => { if (g.date === currentDate) hasPlayed = true; });
  });

  const hasFuture = !!SCHED_BY_DATE[currentDate];

  if (hasPlayed) {
    document.getElementById("pastTableWrap").style.display = "";
    document.getElementById("futureTableWrap").style.display = "none";
    renderPlayedDate();
  } else if (hasFuture) {
    document.getElementById("pastTableWrap").style.display = "none";
    document.getElementById("futureTableWrap").style.display = "";
    renderFutureDate();
  } else {
    document.getElementById("pastTableWrap").style.display = "";
    document.getElementById("futureTableWrap").style.display = "none";
    document.getElementById("tbody").innerHTML = `<tr><td colspan="${COLS.length}" style="text-align:center;padding:24px;color:var(--text-dim)">No games found for this date</td></tr>`;
    document.getElementById("gameCount").textContent = "0 games";
  }
}

/* ---- render PLAYED games for current date ---- */
function renderPlayedDate() {

  /* collect games ‚Äì deduplicate by game_id */
  const seen = new Set();
  const rows = [];

  Object.values(ALL_GAMES).forEach(games => {
    games.forEach(g => {
      if (g.date !== currentDate) return;
      if (seen.has(g.game_id)) return;

      /* only keep one side: home team's row (or alphabetically first for neutral) */
      const isKeep = g.homeAway === "home" || (g.homeAway === "neutral" && g.team_abbr < g.opp_team_abbr);
      if (!isKeep) return;
      seen.add(g.game_id);

      const teamInfo = ALL_TEAMS[g.team_abbr] || {};
      const oppInfo  = ALL_TEAMS[g.opp_team_abbr] || {};
      const teamPts = Math.round(g.points);
      const oppPts  = Math.round(g.points_allowed);
      const teamWon = teamPts > oppPts;

      /* winner / loser */
      const winName  = teamWon ? (g.team_displayName || g.team_abbr) : (g.opp_team_displayName || g.opp_team_abbr);
      const loseName = teamWon ? (g.opp_team_displayName || g.opp_team_abbr) : (g.team_displayName || g.team_abbr);
      const winAbbr  = teamWon ? g.team_abbr : g.opp_team_abbr;
      const loseAbbr = teamWon ? g.opp_team_abbr : g.team_abbr;
      const winPts   = teamWon ? teamPts : oppPts;
      const losePts  = teamWon ? oppPts : teamPts;
      const winInfo  = teamWon ? teamInfo : oppInfo;
      const loseInfo = teamWon ? oppInfo : teamInfo;

      /* winner's location */
      let winLoc;
      if (g.homeAway === "neutral") {
        winLoc = "N";
      } else if (teamWon) {
        winLoc = g.homeAway === "home" ? "H" : "A";
      } else {
        winLoc = g.homeAway === "home" ? "A" : "H";
      }

      /* conference matchup */
      const winConf  = winInfo.conference || "";
      const loseConf = loseInfo.conference || "";
      const matchupConf = (winConf && loseConf && winConf === loseConf) ? winConf : "Non Conf";

      /* projected score using AdjOE, AdjDE, and Tempo */
      const winOE  = winInfo.OffEff_srs, winDE  = winInfo.DefEff_srs, winT  = winInfo.Tempo_srs;
      const loseOE = loseInfo.OffEff_srs, loseDE = loseInfo.DefEff_srs, loseT = loseInfo.Tempo_srs;
      let expectedMargin = null;
      let expectedMarginStr = "‚Äì";
      if (winOE != null && winDE != null && loseOE != null && loseDE != null && winT != null && loseT != null) {
        const poss = winT * loseT / AVG_POSS;
        let winProjOE = winOE, loseProjOE = loseOE;
        if (winLoc === "H") { winProjOE += HOME_ADV / 2; loseProjOE -= HOME_ADV / 2; }
        else if (winLoc === "A") { winProjOE -= HOME_ADV / 2; loseProjOE += HOME_ADV / 2; }
        const winProjPtsRaw  = winProjOE * loseDE / 100 * poss / 100 * SCORE_SCALE;
        const loseProjPtsRaw = loseProjOE * winDE / 100 * poss / 100 * SCORE_SCALE;
        let winProjPts  = Math.round(winProjPtsRaw);
        let loseProjPts = Math.round(loseProjPtsRaw);
        /* break ties: bump the team with the higher raw score */
        if (winProjPts === loseProjPts) {
          if (winProjPtsRaw >= loseProjPtsRaw) winProjPts += 1;
          else loseProjPts += 1;
        }
        expectedMargin = winProjPts - loseProjPts;
        const projFav = winProjPts >= loseProjPts ? winName : loseName;
        const projHi  = Math.max(winProjPts, loseProjPts);
        const projLo  = Math.min(winProjPts, loseProjPts);
        /* check if projected score matches actual exactly */
        const exactMatch = (projHi === winPts && projLo === losePts && projFav === winName);
        expectedMarginStr = `${projFav} ${projHi} - ${projLo}${exactMatch ? " ‚≠ê" : ""}`;
      }

      /* ball score = combined AdjE */
      const winAdjE  = winInfo.net_srs;
      const loseAdjE = loseInfo.net_srs;
      const ballScore = (winAdjE != null && loseAdjE != null) ? winAdjE + loseAdjE : null;

      /* upset score = actual winning margin minus expected margin
         positive = bigger upset / outperformance, negative = underperformance */
      const actualMargin = winPts - losePts;
      const upsetScore = expectedMargin != null ? actualMargin - expectedMargin : null;

      rows.push({
        winner_name: winName,
        winner_abbr: winAbbr,
        loser_name: loseName,
        loser_abbr: loseAbbr,
        score: `${winPts} - ${losePts}`,
        winner_loc: winLoc,
        matchup_conf: matchupConf,
        expected_margin: expectedMarginStr,
        _expected_margin_val: expectedMargin,
        upset_score: upsetScore,
        ball_score: ballScore,
        bubble_impact: bubbleImpact(winAbbr, loseAbbr),
      });
    });
  });

  /* sort */
  rows.sort((a, b) => {
    let va = a[sortCol], vb = b[sortCol];
    /* for expected_margin column, sort by numeric value */
    if (sortCol === "expected_margin") { va = a._expected_margin_val; vb = b._expected_margin_val; }
    if (va == null) return 1; if (vb == null) return -1;
    if (typeof va === "string") { va = va.toLowerCase(); vb = (vb || "").toLowerCase(); }
    return sortAsc ? (va > vb ? 1 : va < vb ? -1 : 0) : (va < vb ? 1 : va > vb ? -1 : 0);
  });

  document.getElementById("gameCount").textContent = `${rows.length} games`;

  /* heatmap bounds */
  const bounds = {};
  COLS.forEach(c => {
    if (!c.heat) return;
    const vals = rows.map(r => r[c.key]).filter(v => v != null);
    if (vals.length) bounds[c.key] = { min: Math.min(...vals), max: Math.max(...vals) };
  });

  /* build table rows */
  const tbody = document.getElementById("tbody");
  const frags = [];
  rows.forEach(r => {
    const cells = COLS.map(c => {
      const v = r[c.key];
      let display = v != null ? c.fmt(v) : "‚Äì";

      if (c.key === "winner_name" && r.winner_abbr) {
        display = `<a href="team.html?team=${encodeURIComponent(r.winner_abbr)}" style="color:var(--accent);text-decoration:none">${display}</a>`;
      }
      if (c.key === "loser_name" && r.loser_abbr) {
        display = `<a href="team.html?team=${encodeURIComponent(r.loser_abbr)}" style="color:var(--accent);text-decoration:none">${display}</a>`;
      }
      if (c.key === "matchup_conf" && v && v !== "Non Conf") {
        display = `<a href="conference.html?conf=${encodeURIComponent(v)}" style="color:var(--accent);text-decoration:none">${display}</a>`;
      }

      let cls = (c.cls ? c.cls(v) : "");
      if (c.key === "expected_margin") {
        /* green if expected winner actually won (margin >= 0), red if upset */
        if (r._expected_margin_val != null) {
          cls += r._expected_margin_val >= 0 ? " win" : " loss";
        }
      }
      const align = c.align || "center";
      let style = `text-align:${align}`;
      if (c.heat && v != null && bounds[c.key]) {
        const bg = heatColor(v, bounds[c.key].min, bounds[c.key].max, c.heat === "low");
        if (bg) style += `;background:${bg}`;
      }
      return `<td style="${style}" class="${cls.trim()} ${c.heat ? 'heatmap' : ''}">${display}</td>`;
    }).join("");
    frags.push(`<tr>${cells}</tr>`);
  });
  tbody.innerHTML = frags.join("");

  /* update header arrows */
  document.querySelectorAll("#headerRow th").forEach((th, i) => {
    const col = COLS[i];
    const arrow = col.key === sortCol ? (sortAsc ? " ‚ñ≤" : " ‚ñº") : "";
    th.textContent = col.label + arrow;
  });
}

/* ---- build future games header ---- */
function buildFutureHeader() {
  const tr = document.getElementById("futureHeaderRow");
  tr.innerHTML = "";
  FUTURE_COLS.forEach(c => {
    const th = document.createElement("th");
    th.textContent = c.label;
    th.style.textAlign = c.align || "center";
    th.addEventListener("click", () => {
      if (futureSortCol === c.key) futureSortAsc = !futureSortAsc;
      else { futureSortCol = c.key; futureSortAsc = c.key === "time"; }  // time defaults ascending
      renderFutureDate();
    });
    tr.appendChild(th);
  });
}

/* ---- render FUTURE games for current date ---- */
function renderFutureDate() {
  const futureGames = SCHED_BY_DATE[currentDate] || [];
  const rows = [];

  futureGames.forEach(g => {
    const teamInfo = ALL_TEAMS[g.team_abbr] || {};
    const oppInfo  = ALL_TEAMS[g.opp_abbr] || {};
    const teamSrs = teamInfo.net_srs;
    const oppSrs  = oppInfo.net_srs;

    /* determine home / away / neutral */
    let homeName, homeAbbr, awayName, awayAbbr;
    if (g.neutralSite) {
      /* list alphabetically by abbr */
      const a = g.team_abbr < g.opp_abbr ? g.team_abbr : g.opp_abbr;
      const b = g.team_abbr < g.opp_abbr ? g.opp_abbr : g.team_abbr;
      homeName = a === g.team_abbr ? (teamInfo.team_displayName || a) : (oppInfo.team_displayName || g.opp_displayName || a);
      homeAbbr = a;
      awayName = b === g.team_abbr ? (teamInfo.team_displayName || b) : (oppInfo.team_displayName || g.opp_displayName || b);
      awayAbbr = b;
    } else if (g.homeAway === "home") {
      homeName = teamInfo.team_displayName || g.team_abbr;
      homeAbbr = g.team_abbr;
      awayName = oppInfo.team_displayName || g.opp_displayName || g.opp_abbr;
      awayAbbr = g.opp_abbr;
    } else {
      awayName = teamInfo.team_displayName || g.team_abbr;
      awayAbbr = g.team_abbr;
      homeName = oppInfo.team_displayName || g.opp_displayName || g.opp_abbr;
      homeAbbr = g.opp_abbr;
    }

    /* conference matchup */
    const homeConf = (ALL_TEAMS[homeAbbr] || {}).conference || "";
    const awayConf = (ALL_TEAMS[awayAbbr] || {}).conference || "";
    const matchupConf = (homeConf && awayConf && homeConf === awayConf) ? homeConf : "Non Conf";

    /* projected score using AdjOE, AdjDE, and Tempo */
    let expectedResult = "‚Äì";
    let _expVal = null;
    const homeInfo = ALL_TEAMS[homeAbbr] || {};
    const awayInfo = ALL_TEAMS[awayAbbr] || {};
    const homeOE = homeInfo.OffEff_srs, homeDE = homeInfo.DefEff_srs, homeT = homeInfo.Tempo_srs;
    const awayOE = awayInfo.OffEff_srs, awayDE = awayInfo.DefEff_srs, awayT = awayInfo.Tempo_srs;
    if (homeOE != null && homeDE != null && awayOE != null && awayDE != null && homeT != null && awayT != null) {
      const poss = homeT * awayT / AVG_POSS;
      let adjHomeOE = homeOE, adjAwayOE = awayOE;
      if (!g.neutralSite) { adjHomeOE += HOME_ADV / 2; adjAwayOE -= HOME_ADV / 2; }
      const homeProjPtsRaw = adjHomeOE * awayDE / 100 * poss / 100 * SCORE_SCALE;
      const awayProjPtsRaw = adjAwayOE * homeDE / 100 * poss / 100 * SCORE_SCALE;
      let homeProjPts = Math.round(homeProjPtsRaw);
      let awayProjPts = Math.round(awayProjPtsRaw);
      /* break ties: bump the team with the higher raw score */
      if (homeProjPts === awayProjPts) {
        if (homeProjPtsRaw >= awayProjPtsRaw) homeProjPts += 1;
        else awayProjPts += 1;
      }
      _expVal = homeProjPts - awayProjPts;
      const projFav = homeProjPts >= awayProjPts ? homeName : awayName;
      const projHi  = Math.max(homeProjPts, awayProjPts);
      const projLo  = Math.min(homeProjPts, awayProjPts);
      expectedResult = `${projFav} ${projHi} - ${projLo}`;
    }

    /* ball score = combined AdjE */
    const homeSrs = homeInfo.net_srs;
    const awaySrs = awayInfo.net_srs;
    const ballScore = (homeSrs != null && awaySrs != null) ? homeSrs + awaySrs : null;

    /* time from time_detail, strip date prefix */
    let time = "";
    let _timeSortVal = 9999; // default: no time ‚Üí sort last
    if (g.time_detail) {
      const m = g.time_detail.match(/(\d+):(\d+)\s*(AM|PM)\s*(\w*)/);
      if (m) {
        time = m[0];
        let hrs = parseInt(m[1]);
        const mins = parseInt(m[2]);
        const ampm = m[3];
        if (ampm === "PM" && hrs !== 12) hrs += 12;
        if (ampm === "AM" && hrs === 12) hrs = 0;
        _timeSortVal = hrs * 60 + mins;
      } else {
        time = g.time_detail;
      }
    }

    rows.push({
      away_name: awayName, away_abbr: awayAbbr,
      home_name: homeName, home_abbr: homeAbbr,
      matchup_conf: matchupConf,
      time: time,
      _time_sort: _timeSortVal,
      expected_result: expectedResult,
      _expected_result_val: _expVal,
      ball_score: ballScore,
      bubble_impact: bubbleImpact(homeAbbr, awayAbbr),
    });
  });

  /* sort */
  rows.sort((a, b) => {
    let va = a[futureSortCol], vb = b[futureSortCol];
    if (futureSortCol === "expected_result") { va = a._expected_result_val; vb = b._expected_result_val; }
    if (futureSortCol === "time") { va = a._time_sort; vb = b._time_sort; }
    if (va == null) return 1; if (vb == null) return -1;
    if (typeof va === "string") { va = va.toLowerCase(); vb = (vb || "").toLowerCase(); }
    return futureSortAsc ? (va > vb ? 1 : va < vb ? -1 : 0) : (va < vb ? 1 : va > vb ? -1 : 0);
  });

  document.getElementById("gameCount").textContent = `${rows.length} upcoming games`;

  /* heatmap bounds */
  const bounds = {};
  FUTURE_COLS.forEach(c => {
    if (!c.heat) return;
    const vals = rows.map(r => r[c.key]).filter(v => v != null);
    if (vals.length) bounds[c.key] = { min: Math.min(...vals), max: Math.max(...vals) };
  });

  /* build table rows */
  const tbody = document.getElementById("futureTbody");
  const frags = [];
  rows.forEach(r => {
    const cells = FUTURE_COLS.map(c => {
      const v = r[c.key];
      let display = v != null ? c.fmt(v) : "‚Äì";

      if (c.key === "away_name" && r.away_abbr) {
        display = `<a href="team.html?team=${encodeURIComponent(r.away_abbr)}" style="color:var(--accent);text-decoration:none">${display}</a>`;
      }
      if (c.key === "home_name" && r.home_abbr) {
        display = `<a href="team.html?team=${encodeURIComponent(r.home_abbr)}" style="color:var(--accent);text-decoration:none">${display}</a>`;
      }
      if (c.key === "matchup_conf" && v && v !== "Non Conf") {
        display = `<a href="conference.html?conf=${encodeURIComponent(v)}" style="color:var(--accent);text-decoration:none">${display}</a>`;
      }

      let cls = (c.cls ? c.cls(v) : "");
      const align = c.align || "center";
      let style = `text-align:${align}`;
      if (c.heat && v != null && bounds[c.key]) {
        const bg = heatColor(v, bounds[c.key].min, bounds[c.key].max, c.heat === "low");
        if (bg) style += `;background:${bg}`;
      }
      return `<td style="${style}" class="${cls.trim()} ${c.heat ? 'heatmap' : ''}">${display}</td>`;
    }).join("");
    frags.push(`<tr>${cells}</tr>`);
  });
  tbody.innerHTML = frags.join("");

  /* update header arrows */
  document.querySelectorAll("#futureHeaderRow th").forEach((th, i) => {
    const col = FUTURE_COLS[i];
    const arrow = col.key === futureSortCol ? (futureSortAsc ? " ‚ñ≤" : " ‚ñº") : "";
    th.textContent = col.label + arrow;
  });
}

/* ---- helper: build a game row object from a per-game record ---- */
function buildGameRow(g) {
  const teamInfo = ALL_TEAMS[g.team_abbr] || {};
  const oppInfo  = ALL_TEAMS[g.opp_team_abbr] || {};
  const teamPts = Math.round(g.points);
  const oppPts  = Math.round(g.points_allowed);
  const teamWon = teamPts > oppPts;

  const winName  = teamWon ? (g.team_displayName || g.team_abbr) : (g.opp_team_displayName || g.opp_team_abbr);
  const loseName = teamWon ? (g.opp_team_displayName || g.opp_team_abbr) : (g.team_displayName || g.team_abbr);
  const winAbbr  = teamWon ? g.team_abbr : g.opp_team_abbr;
  const loseAbbr = teamWon ? g.opp_team_abbr : g.team_abbr;
  const winPts   = teamWon ? teamPts : oppPts;
  const losePts  = teamWon ? oppPts : teamPts;
  const winInfo  = teamWon ? teamInfo : oppInfo;
  const loseInfo = teamWon ? oppInfo : teamInfo;

  let winLoc;
  if (g.homeAway === "neutral") winLoc = "N";
  else if (teamWon) winLoc = g.homeAway === "home" ? "H" : "A";
  else winLoc = g.homeAway === "home" ? "A" : "H";

  const winConf  = winInfo.conference || "";
  const loseConf = loseInfo.conference || "";
  const matchupConf = (winConf && loseConf && winConf === loseConf) ? winConf : "Non Conf";

  const winAdjE  = winInfo.net_srs;
  const loseAdjE = loseInfo.net_srs;
  const winOE  = winInfo.OffEff_srs, winDE  = winInfo.DefEff_srs, winT  = winInfo.Tempo_srs;
  const loseOE = loseInfo.OffEff_srs, loseDE = loseInfo.DefEff_srs, loseT = loseInfo.Tempo_srs;
  let expectedMargin = null;
  let expectedMarginStr = "‚Äì";
  if (winOE != null && winDE != null && loseOE != null && loseDE != null && winT != null && loseT != null) {
    const poss = winT * loseT / AVG_POSS;
    let winProjOE = winOE, loseProjOE = loseOE;
    if (winLoc === "H") { winProjOE += HOME_ADV / 2; loseProjOE -= HOME_ADV / 2; }
    else if (winLoc === "A") { winProjOE -= HOME_ADV / 2; loseProjOE += HOME_ADV / 2; }
    const winProjPts  = Math.round(winProjOE * loseDE / 100 * poss / 100);
    const loseProjPts = Math.round(loseProjOE * winDE / 100 * poss / 100);
    expectedMargin = winProjPts - loseProjPts;
    const projFav = winProjPts >= loseProjPts ? winName : loseName;
    const projHi  = Math.max(winProjPts, loseProjPts);
    const projLo  = Math.min(winProjPts, loseProjPts);
    expectedMarginStr = `${projFav} ${projHi} - ${projLo}`;
  }

  const actualMargin = winPts - losePts;
  const upsetScore = expectedMargin != null ? actualMargin - expectedMargin : null;

  return {
    date: g.date,
    winner_name: winName, winner_abbr: winAbbr,
    loser_name: loseName, loser_abbr: loseAbbr,
    score: `${winPts} - ${losePts}`,
    winner_loc: winLoc, matchup_conf: matchupConf,
    expected_margin: expectedMarginStr,
    _expected_margin_val: expectedMargin,
    upset_score: upsetScore,
    ball_score: (winAdjE != null && loseAdjE != null) ? winAdjE + loseAdjE : null,
  };
}

/* ---- biggest upsets tab ---- */
function buildUpsetsHeader() {
  const tr = document.getElementById("upsetsHeaderRow");
  tr.innerHTML = "";
  UPSET_COLS.forEach(c => {
    const th = document.createElement("th");
    th.textContent = c.label;
    th.style.textAlign = c.align || "center";
    th.addEventListener("click", () => {
      if (upsetSortCol === c.key) upsetSortAsc = !upsetSortAsc;
      else { upsetSortCol = c.key; upsetSortAsc = false; }
      renderUpsets();
    });
    tr.appendChild(th);
  });
}

function renderUpsets() {
  /* collect ALL games across ALL dates, deduplicate */
  const seen = new Set();
  const rows = [];
  Object.values(ALL_GAMES).forEach(games => {
    games.forEach(g => {
      if (seen.has(g.game_id)) return;
      const isKeep = g.homeAway === "home" || (g.homeAway === "neutral" && g.team_abbr < g.opp_team_abbr);
      if (!isKeep) return;
      seen.add(g.game_id);
      const row = buildGameRow(g);
      /* only include actual upsets: winner was expected to lose (expected_margin < 0) */
      if (row._expected_margin_val != null && row._expected_margin_val < 0) {
        rows.push(row);
      }
    });
  });

  /* sort */
  rows.sort((a, b) => {
    let va = a[upsetSortCol], vb = b[upsetSortCol];
    if (upsetSortCol === "expected_margin") { va = a._expected_margin_val; vb = b._expected_margin_val; }
    if (va == null) return 1; if (vb == null) return -1;
    if (typeof va === "string") { va = va.toLowerCase(); vb = (vb || "").toLowerCase(); }
    return upsetSortAsc ? (va > vb ? 1 : va < vb ? -1 : 0) : (va < vb ? 1 : va > vb ? -1 : 0);
  });

  document.getElementById("gameCount").textContent = `${rows.length} upsets`;

  const tbody = document.getElementById("upsetsTbody");
  const frags = [];
  rows.forEach((r, i) => {
    r._rank = i + 1;
    const cells = UPSET_COLS.map(c => {
      const v = c.key === "_rank" ? r._rank : r[c.key];
      let display = v != null ? c.fmt(v) : "‚Äì";

      if (c.key === "winner_name" && r.winner_abbr) {
        display = `<a href="team.html?team=${encodeURIComponent(r.winner_abbr)}" style="color:var(--accent);text-decoration:none">${display}</a>`;
      }
      if (c.key === "loser_name" && r.loser_abbr) {
        display = `<a href="team.html?team=${encodeURIComponent(r.loser_abbr)}" style="color:var(--accent);text-decoration:none">${display}</a>`;
      }
      if (c.key === "matchup_conf" && v && v !== "Non Conf") {
        display = `<a href="conference.html?conf=${encodeURIComponent(v)}" style="color:var(--accent);text-decoration:none">${display}</a>`;
      }
      if (c.key === "date" && v) {
        display = `<a href="game_date.html?date=${encodeURIComponent(v)}" style="color:var(--accent);text-decoration:none">${v}</a>`;
      }

      let cls = (c.cls ? c.cls(v) : "");
      if (c.key === "expected_margin" && r._expected_margin_val != null) {
        cls += r._expected_margin_val >= 0 ? " win" : " loss";
      }
      const align = c.align || "center";
      return `<td style="text-align:${align}" class="${cls.trim()}">${display}</td>`;
    }).join("");
    frags.push(`<tr>${cells}</tr>`);
  });
  tbody.innerHTML = frags.join("");

  /* update header arrows */
  document.querySelectorAll("#upsetsHeaderRow th").forEach((th, i) => {
    const col = UPSET_COLS[i];
    const arrow = col.key === upsetSortCol ? (upsetSortAsc ? " ‚ñ≤" : " ‚ñº") : "";
    th.textContent = col.label + arrow;
  });
}
</script>
</body>
</html>
