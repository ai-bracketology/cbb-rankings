<!DOCTYPE html>
<html lang="en">
<head>
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-020D2NVH9F"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-020D2NVH9F');
</script>
<meta charset="UTF-8">
<link rel="icon" type="image/png" href="favicon.png">
<link rel="apple-touch-icon" href="favicon.png">
<meta property="og:title" content="Team Detail ‚Äî AIB College Basketball Ratings">
<meta property="og:description" content="College basketball rankings, bracketology, and analytics powered by AI Bracketology">
<meta property="og:image" content="https://ai-bracketology.github.io/cbb-rankings/docs/new_header.png">
<meta property="og:type" content="website">
<meta name="twitter:card" content="summary_large_image">
<meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
<meta http-equiv="Pragma" content="no-cache">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Team Detail ‚Äî CBB Ratings 2025-26</title>
<script>
  (function(){
    var t = localStorage.getItem("cbb_theme");
    if (t === "light") document.documentElement.setAttribute("data-theme","light");
  })();
  /* reload when restored from bfcache (back/forward navigation) */
  window.addEventListener("pageshow", function(e) {
    if (e.persisted) window.location.reload();
  });
</script>
<style>
  :root {
    --bg:        #0d1117;
    --surface:   #161b22;
    --border:    #30363d;
    --text:      #c9d1d9;
    --text-dim:  #8b949e;
    --accent:    #58a6ff;
    --green:     #3fb950;
    --red:       #f85149;
    --gold:      #d29922;
  }
  html[data-theme="light"] {
    --bg:        #ffffff;
    --surface:   #f6f8fa;
    --border:    #d0d7de;
    --text:      #1f2328;
    --text-dim:  #656d76;
    --accent:    #0969da;
    --green:     #1a7f37;
    --red:       #cf222e;
    --gold:      #9a6700;
  }
  * { box-sizing: border-box; margin: 0; padding: 0; }
  body {
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, Arial, sans-serif;
    background: var(--bg);
    color: var(--text);
    line-height: 1.5;
  }

  /* header */
  header {
    background: var(--surface);
    border-bottom: 1px solid var(--border);
    padding: 20px 32px;
    display: flex;
    align-items: center;
    gap: 16px;
  }
  header a.back {
    color: var(--accent);
    text-decoration: none;
    font-size: .85rem;
  }
  header a.back:hover { text-decoration: underline; }
  header h1 { font-size: 1.4rem; font-weight: 600; }
  header .record { color: var(--text-dim); font-size: .9rem; margin-left: auto; }

  /* theme toggle */
  .theme-toggle {
    background: var(--surface);
    border: 1px solid var(--border);
    color: var(--text);
    font-size: 1.1rem;
    padding: 5px 10px;
    border-radius: 6px;
    cursor: pointer;
    transition: border-color .15s;
    line-height: 1;
  }
  .theme-toggle:hover { border-color: var(--accent); }

  /* summary strip */
  .summary {
    max-width: 1500px;
    margin: 20px auto 0;
    padding: 0 20px;
    display: flex;
    gap: 12px;
    flex-wrap: wrap;
  }
  .summary .chip {
    background: var(--surface);
    border: 1px solid var(--border);
    border-radius: 6px;
    padding: 10px 18px;
    font-size: .95rem;
  }
  .chip .val { font-weight: 700; color: var(--accent); font-size: 1.05rem; }

  /* table */
  .table-wrap {
    max-width: 1500px;
    margin: 16px auto 40px;
    padding: 0 20px;
    overflow-x: auto;
  }
  table {
    width: 100%;
    border-collapse: collapse;
    font-size: .8rem;
  }
  thead { position: sticky; top: 0; z-index: 2; }
  thead th {
    background: var(--surface);
    border-bottom: 2px solid var(--border);
    color: var(--text-dim);
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: .03em;
    padding: 10px 7px;
    cursor: pointer;
    white-space: normal;
    user-select: none;
    text-align: center;
    line-height: 1.25;
  }
  thead th:hover { color: var(--accent); }

  tbody tr { border-bottom: 1px solid var(--border); }
  tbody tr:hover { background: rgba(88,166,255,.06); }
  tbody td {
    padding: 8px 7px;
    white-space: nowrap;
    text-align: center;
  }

  .win { color: var(--green); font-weight: 600; }
  .loss { color: var(--red); font-weight: 600; }
  .eff-good { color: var(--green); }
  .eff-bad  { color: var(--red); }

  /* quad labels */
  .quad-1 { color: #f0c040; font-weight: 700; }
  .quad-2 { color: var(--accent); font-weight: 600; }
  .quad-3 { color: var(--green); font-weight: 600; }
  .quad-4 { color: var(--text-dim); }

  /* narrow stacked header columns */
  .narrow-col { max-width: 52px; min-width: 40px; }

  /* heatmap cell */
  .heatmap {
    font-weight: 600;
    border-radius: 3px;
    padding: 4px 6px;
  }

  /* section divider for grouped columns */
  .section-start {
    border-left: 2px solid var(--accent) !important;
  }
  .section-end {
    border-right: 2px solid var(--accent) !important;
  }

  /* sub-tabs under Game Log */
  .sub-tabs {
    max-width: 1500px;
    margin: 10px auto 0;
    padding: 0 20px;
    display: flex;
    gap: 4px;
  }
  .sub-tab-btn {
    background: var(--surface);
    border: 1px solid var(--border);
    border-radius: 6px;
    color: var(--text-dim);
    padding: 6px 16px;
    font-size: .78rem;
    font-weight: 600;
    cursor: pointer;
    transition: color .15s, border-color .15s;
  }
  .sub-tab-btn:hover { color: var(--text); }
  .sub-tab-btn.active { color: var(--accent); border-color: var(--accent); }

  /* section header row spanning the table */
  .section-hdr {
    background: rgba(88,166,255,.06);
    color: var(--text-dim);
    font-size: .7rem;
    font-weight: 700;
    text-transform: uppercase;
    letter-spacing: .05em;
    padding: 3px 7px;
    text-align: center;
    border-bottom: 2px solid var(--accent);
  }

  /* subtle background for stat columns in off/def views */

  footer {
    text-align: center;
    padding: 24px;
    color: var(--text-dim);
    font-size: .75rem;
    border-top: 1px solid var(--border);
  }
  footer a { color: var(--accent); text-decoration: none; }

  /* ---------- tabs ---------- */
  .tabs {
    max-width: 1500px;
    margin: 20px auto 0;
    padding: 0 20px;
    display: flex;
    gap: 4px;
  }
  .tab-btn {
    background: var(--surface);
    border: 1px solid var(--border);
    border-bottom: none;
    border-radius: 6px 6px 0 0;
    color: var(--text-dim);
    padding: 9px 20px;
    font-size: .85rem;
    font-weight: 600;
    cursor: pointer;
    transition: color .15s, border-color .15s;
  }
  .tab-btn:hover { color: var(--text); }
  .tab-btn.active {
    color: var(--accent);
    border-color: var(--accent);
    background: var(--bg);
  }

  /* ---------- chart containers ---------- */
  .chart-wrap {
    max-width: 1500px;
    margin: 16px auto 40px;
    padding: 0 20px;
    display: none;
  }
  .chart-box {
    background: var(--surface);
    border: 1px solid var(--border);
    border-radius: 8px;
    padding: 24px;
    position: relative;
  }
  .chart-box canvas {
    width: 100%;
    height: 400px;
    display: block;
  }

  /* ---------- chart tooltip ---------- */
  .chart-tooltip {
    position: absolute;
    pointer-events: none;
    background: var(--surface);
    border: 1px solid var(--border);
    border-radius: 6px;
    padding: 8px 12px;
    font-size: .78rem;
    line-height: 1.5;
    color: var(--text);
    white-space: nowrap;
    z-index: 10;
    box-shadow: 0 4px 12px rgba(0,0,0,.4);
    display: none;
    transform: translate(-50%, -100%);
    margin-top: -10px;
  }
  .chart-tooltip .tt-date { color: var(--text-dim); font-size: .72rem; }
  .chart-tooltip .tt-opp  { font-weight: 600; color: var(--accent); }
  .chart-tooltip .tt-val  { font-weight: 700; }
  .chart-tooltip .tt-pos  { color: var(--green); }
  .chart-tooltip .tt-neg  { color: var(--red); }

  /* ---------- splits table ---------- */
  .splits-wrap {
    max-width: 1500px;
    margin: 16px auto 0;
    padding: 0 20px;
  }
  .splits-wrap h3 {
    font-size: .85rem;
    font-weight: 600;
    color: var(--text-dim);
    text-transform: uppercase;
    letter-spacing: .04em;
    margin-bottom: 8px;
  }
  .splits-table {
    width: 100%;
    max-width: 700px;
    border-collapse: collapse;
    font-size: .82rem;
  }
  .splits-table th {
    background: var(--surface);
    border-bottom: 2px solid var(--border);
    color: var(--text-dim);
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: .03em;
    padding: 8px 10px;
    text-align: center;
  }
  .splits-table th:first-child { text-align: left; }
  .splits-table td {
    padding: 7px 10px;
    border-bottom: 1px solid var(--border);
    text-align: center;
  }
  .splits-table td:first-child { text-align: left; font-weight: 600; }
  .net-pos { color: var(--green); font-weight: 600; }
  .net-neg { color: var(--red); }

  /* ---------- mobile responsive ---------- */
  @media (max-width: 768px) {
    header {
      flex-direction: column;
      align-items: flex-start;
      padding: 14px 16px;
      gap: 6px;
    }
    header h1 { font-size: 1.15rem; }
    header .record { margin-left: 0; font-size: .8rem; }

    .summary { padding: 0 12px; gap: 8px; }
    .chip { padding: 8px 12px !important; font-size: .82rem !important; }

    .tabs {
      overflow-x: auto;
      -webkit-overflow-scrolling: touch;
      scrollbar-width: none;
      flex-wrap: nowrap;
      padding: 0 12px;
      gap: 2px;
    }
    .tabs::-webkit-scrollbar { display: none; }
    .tab-btn {
      padding: 7px 12px;
      font-size: .73rem;
      white-space: nowrap;
      flex-shrink: 0;
    }

    .sub-tabs {
      overflow-x: auto;
      -webkit-overflow-scrolling: touch;
      scrollbar-width: none;
      padding: 0 12px;
      gap: 2px;
    }
    .sub-tabs::-webkit-scrollbar { display: none; }
    .sub-tab-btn {
      padding: 5px 10px;
      font-size: .7rem;
      white-space: nowrap;
      flex-shrink: 0;
    }

    .table-wrap {
      padding: 0 8px;
      -webkit-overflow-scrolling: touch;
    }
    table { font-size: .72rem; }
    thead th { padding: 7px 4px; font-size: .68rem; }
    tbody td { padding: 6px 4px; }

    .chart-wrap { padding: 0 12px; }
    .chart-box { padding: 12px; }
    .chart-box canvas { height: 280px; }

    .splits-wrap { padding: 0 12px; }
    .splits-table { font-size: .75rem; }
    .splits-table th, .splits-table td { padding: 6px 6px; }
  }

  @media (max-width: 480px) {
    header h1 { font-size: 1rem; }
    .summary { flex-direction: column; }
    .chip { width: 100%; }
    .chart-box canvas { height: 220px; }
    .whatif-cards { flex-direction: column; }
    .whatif-card { min-width: unset; }
  }

  /* ---------- what-if simulator ---------- */
  .whatif-wrap {
    max-width: 1500px;
    margin: 0 auto 12px;
    padding: 0 20px;
    display: none;
  }
  .whatif-header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    margin-bottom: 10px;
  }
  .whatif-header h3 {
    font-size: .9rem;
    font-weight: 700;
    color: var(--accent);
    text-transform: uppercase;
    letter-spacing: .04em;
  }
  .whatif-reset {
    background: transparent;
    border: 1px solid var(--border);
    border-radius: 4px;
    color: var(--text-dim);
    padding: 4px 12px;
    font-size: .75rem;
    cursor: pointer;
    transition: color .15s, border-color .15s;
  }
  .whatif-reset:hover { color: var(--accent); border-color: var(--accent); }

  .whatif-cards {
    display: flex;
    gap: 14px;
    flex-wrap: wrap;
  }
  .whatif-card {
    background: var(--surface);
    border: 1px solid var(--border);
    border-radius: 8px;
    padding: 14px 22px;
    min-width: 160px;
    text-align: center;
    flex: 1;
  }
  .whatif-card .wc-label {
    font-size: .72rem;
    font-weight: 600;
    color: var(--text-dim);
    text-transform: uppercase;
    letter-spacing: .04em;
    margin-bottom: 4px;
  }
  .whatif-card .wc-value {
    font-size: 1.6rem;
    font-weight: 800;
    color: var(--accent);
    line-height: 1.2;
  }
  .whatif-card .wc-sub {
    font-size: .72rem;
    color: var(--text-dim);
    margin-top: 2px;
  }
  .whatif-card .wc-delta {
    font-size: .78rem;
    font-weight: 700;
    margin-top: 2px;
  }
  .wc-delta.up { color: var(--green); }
  .wc-delta.down { color: var(--red); }
  .wc-delta.flat { color: var(--text-dim); }

  /* win/loss toggle buttons in schedule table */
  .wl-toggle {
    display: inline-flex;
    gap: 0;
    border-radius: 4px;
    overflow: hidden;
    border: 1px solid var(--border);
  }
  .wl-btn {
    padding: 3px 10px;
    font-size: .72rem;
    font-weight: 700;
    cursor: pointer;
    border: none;
    background: transparent;
    color: var(--text-dim);
    transition: all .15s;
  }
  .wl-btn:first-child { border-right: 1px solid var(--border); }
  .wl-btn.sel-win {
    background: rgba(63,185,80,.2);
    color: var(--green);
  }
  .wl-btn.sel-loss {
    background: rgba(248,81,73,.2);
    color: var(--red);
  }
</style>
</head>
<body>

<header>
  <a class="back" href="index.html">‚Üê Back to Rankings</a>
  <h1 id="teamName">Loading‚Ä¶</h1>
  <span class="record" id="record"></span>
  <button class="theme-toggle" id="themeToggle" title="Toggle light/dark mode">üåô</button>
</header>

<div class="summary" id="summary"></div>

<div class="splits-wrap" id="splitsWrap"></div>

<div class="tabs">
  <button class="tab-btn active" id="tabLog">Game Log</button>
  <button class="tab-btn" id="tabSched">Future Schedule</button>
  <button class="tab-btn" id="tabWab">WAB Trend</button>
  <button class="tab-btn" id="tabAdjE">AdjE vs Expected</button>
</div>

<div class="sub-tabs" id="subTabsWrap">
  <button class="sub-tab-btn active" id="subLog">Box Score</button>
  <button class="sub-tab-btn" id="subOff">Offensive Stats</button>
  <button class="sub-tab-btn" id="subDef">Defensive Stats</button>
</div>

<div class="table-wrap" id="tableWrap">
  <table>
    <thead>
      <tr id="headerRow"></tr>
    </thead>
    <tbody id="tbody"></tbody>
  </table>
</div>

<div class="whatif-wrap" id="whatifWrap">
  <div class="whatif-header">
    <h3>üìä What-If Simulator</h3>
    <button class="whatif-reset" id="whatifReset">Reset all</button>
  </div>
  <div class="whatif-cards">
    <div class="whatif-card">
      <div class="wc-label">Projected Record</div>
      <div class="wc-value" id="wiRecord">‚Äì</div>
      <div class="wc-sub" id="wiRecordSub"></div>
    </div>
    <div class="whatif-card">
      <div class="wc-label">Tournament Odds</div>
      <div class="wc-value" id="wiMakePct">‚Äì</div>
      <div class="wc-delta" id="wiMakeDelta"></div>
    </div>
    <div class="whatif-card">
      <div class="wc-label">Projected Seed</div>
      <div class="wc-value" id="wiSeed">‚Äì</div>
      <div class="wc-delta" id="wiSeedDelta"></div>
    </div>
    <div class="whatif-card">
      <div class="wc-label">Projected WAB</div>
      <div class="wc-value" id="wiWab">‚Äì</div>
      <div class="wc-delta" id="wiWabDelta"></div>
    </div>
  </div>
</div>

<div class="table-wrap" id="scheduleWrap" style="display:none">
  <table>
    <thead id="schedHead"></thead>
    <tbody id="schedBody"></tbody>
  </table>
</div>

<div class="chart-wrap" id="simChartWrap">
  <div class="chart-box">
    <canvas id="simCanvas"></canvas>
    <div class="chart-tooltip" id="simTooltip"></div>
  </div>
</div>

<div class="chart-wrap" id="wabChartWrap">
  <div class="chart-box">
    <canvas id="wabCanvas"></canvas>
    <div class="chart-tooltip" id="wabTooltip"></div>
  </div>
</div>

<div class="chart-wrap" id="adjeChartWrap">
  <div class="chart-box">
    <canvas id="adjeCanvas"></canvas>
    <div class="chart-tooltip" id="adjeTooltip"></div>
  </div>
</div>

<footer>
  Built by <a href="https://github.com/ai-bracketology">AI Bracketology</a> ¬∑ Data sourced from ESPN
</footer>

<script>
/* ---- theme toggle ---- */
(function initThemeToggle() {
  const btn = document.getElementById("themeToggle");
  const isLight = document.documentElement.getAttribute("data-theme") === "light";
  btn.textContent = isLight ? "‚òÄÔ∏è" : "üåô";
  btn.addEventListener("click", () => {
    const nowLight = document.documentElement.getAttribute("data-theme") === "light";
    if (nowLight) {
      document.documentElement.removeAttribute("data-theme");
      localStorage.setItem("cbb_theme", "dark");
      btn.textContent = "üåô";
    } else {
      document.documentElement.setAttribute("data-theme", "light");
      localStorage.setItem("cbb_theme", "light");
      btn.textContent = "‚òÄÔ∏è";
    }
    // Re-render any visible charts so colours update
    if (typeof renderWabChart === "function") try { renderWabChart(); } catch(e){}
    if (typeof renderAdjEChart === "function") try { renderAdjEChart(); } catch(e){}
    if (typeof renderSimChart === "function") try { renderSimChart(); } catch(e){}
  });
})();

/* ---- theme-aware color helper ---- */
function themeColor(varName) {
  return getComputedStyle(document.documentElement).getPropertyValue(varName).trim();
}

/* ---- column definitions ---- */
/* shared columns that always show */
const SHARED_COLS = [
  { key: "date",                          label: "Date",              fmt: v => v, align: "left" },
  { key: "opp_team_displayName",          label: "Opponent",          fmt: v => v, align: "left" },
  { key: "_loc",                          label: "Loc",               fmt: v => v, align: "left" },
  { key: "_result",                       label: "Result",            fmt: v => v },
  { key: "quad",                          label: "Quad",              fmt: v => v != null ? `Q${v}` : "‚Äì" },
];

/* box-score columns (default view) */
const BOX_COLS = [
  { key: "totalRebounds",                label: "REB",               fmt: v => v != null ? Math.round(v) : "‚Äì" },
  { key: "assists",                       label: "AST",               fmt: v => v != null ? Math.round(v) : "‚Äì" },
  { key: "steals",                        label: "STL",               fmt: v => v != null ? Math.round(v) : "‚Äì" },
  { key: "blocks",                        label: "BLK",               fmt: v => v != null ? Math.round(v) : "‚Äì" },
  { key: "turnovers",                     label: "TO",                fmt: v => v != null ? Math.round(v) : "‚Äì" },
  { key: "fouls",                         label: "PF",                fmt: v => v != null ? Math.round(v) : "‚Äì" },
  { key: "_fg",                           label: "FGM/\nFGA",        fmt: v => v },
  { key: "_fg_pct",                       label: "FG%",               fmt: v => v },
  { key: "_3fg",                          label: "3PM/\n3PA",        fmt: v => v },
  { key: "_3fg_pct",                      label: "3P%",               fmt: v => v },
  { key: "_ft",                           label: "FTM/\nFTA",        fmt: v => v },
  { key: "_ft_pct",                       label: "FT%",               fmt: v => v },
  { key: "wab",                          label: "WAB",               fmt: v => v != null ? (v >= 0 ? "+" : "") + v.toFixed(3) : "‚Äì" },
  { key: "_cum_wab",                     label: "WAB-to-\nDate",     fmt: v => v != null ? (v >= 0 ? "+" : "") + v.toFixed(1) : "‚Äì" },
];

/* offensive stats columns */
const OFF_COLS = [
  /* Shooting */
  { key: "_efg_pct",    label: "eFG%",        fmt: v => v, sectionStart: true, section: "Shooting" },
  { key: "_3pt_rate",   label: "3PT\nRate",    fmt: v => v, narrow: true },
  { key: "_3pt_pct",    label: "3PT%",         fmt: v => v },
  { key: "_ftr",        label: "FTR",          fmt: v => v },
  { key: "_ft_pct",     label: "FT%",          fmt: v => v, sectionEnd: true },
  /* Ball Control */
  { key: "_ast_rate",   label: "AST\nRate",    fmt: v => v, narrow: true, sectionStart: true, section: "Ball Control" },
  { key: "_or_pct",     label: "OR%",          fmt: v => v },
  { key: "_dr_pct",     label: "DR%",          fmt: v => v },
  { key: "_off_to_pct", label: "Off\nTO%",     fmt: v => v, narrow: true },
  { key: "_stl_pct",    label: "STL%",         fmt: v => v },
  { key: "_blk_pct",    label: "BLK%",         fmt: v => v, sectionEnd: true },
  /* Scoring Breakdown */
  { key: "_to_pts_pct", label: "TO Pts\n%",    fmt: v => v, narrow: true, sectionStart: true, section: "Scoring Breakdown" },
  { key: "_fb_pts_pct", label: "FSTBRK\nPts %", fmt: v => v, narrow: true },
  { key: "_pip_pct",    label: "Paint\n%",     fmt: v => v, narrow: true, sectionEnd: true },
];

/* defensive stats columns (opponent stats) */
const DEF_COLS = [
  /* Shooting (opponent) */
  { key: "_opp_efg_pct",    label: "Opp\neFG%",     fmt: v => v, sectionStart: true, section: "Opp Shooting" },
  { key: "_opp_3pt_rate",   label: "Opp 3PT\nRate",  fmt: v => v, narrow: true },
  { key: "_opp_3pt_pct",    label: "Opp\n3PT%",      fmt: v => v },
  { key: "_opp_ftr",        label: "Opp\nFTR",       fmt: v => v },
  { key: "_opp_ft_pct",     label: "Opp\nFT%",       fmt: v => v, sectionEnd: true },
  /* Ball Control (opponent) */
  { key: "_opp_ast_rate",   label: "Opp AST\nRate",  fmt: v => v, narrow: true, sectionStart: true, section: "Opp Ball Control" },
  { key: "_opp_or_pct",     label: "Opp\nOR%",       fmt: v => v },
  { key: "_opp_dr_pct",     label: "Opp\nDR%",       fmt: v => v },
  { key: "_opp_off_to_pct", label: "Opp Off\nTO%",   fmt: v => v, narrow: true },
  { key: "_opp_stl_pct",    label: "Opp\nSTL%",      fmt: v => v },
  { key: "_opp_blk_pct",    label: "Opp\nBLK%",      fmt: v => v, sectionEnd: true },
  /* Scoring Breakdown (opponent) */
  { key: "_opp_to_pts_pct", label: "Opp TO\nPts %",  fmt: v => v, narrow: true, sectionStart: true, section: "Opp Scoring Breakdown" },
  { key: "_opp_fb_pts_pct", label: "Opp FSTBRK\nPts %", fmt: v => v, narrow: true },
  { key: "_opp_pip_pct",    label: "Opp Paint\n%",   fmt: v => v, narrow: true, sectionEnd: true },
];

/* efficiency columns (always at the end) */
const EFF_COLS = [
  { key: "OffEff_game_adj",              label: "Adj OE",            fmt: v => v != null ? v.toFixed(1) : "‚Äì", heatmap: "off" },
  { key: "DefEff_game_adj",              label: "Adj DE",            fmt: v => v != null ? v.toFixed(1) : "‚Äì", heatmap: "def" },
];

let activeView = "box"; // "box", "off", "def"
let GAMES = [];
let TEAM_INFO = {};
let ALL_TEAMS = {}; // abbr -> team data lookup
let SIM_TEAM = null; // simulation results for this team

function activeCols() {
  if (activeView === "off") return [...SHARED_COLS, ...OFF_COLS, ...EFF_COLS];
  if (activeView === "def") return [...SHARED_COLS, ...DEF_COLS, ...EFF_COLS];
  return [...SHARED_COLS, ...BOX_COLS, ...EFF_COLS];
}

const params = new URLSearchParams(window.location.search);
const teamAbbr = params.get("team");

if (!teamAbbr) {
  document.getElementById("teamName").textContent = "No team specified";
}

/* ---- load data ---- */
Promise.all([
  fetch("games.json").then(r => r.json()),
  fetch("data.json").then(r => r.json()),
  fetch("schedule.json").then(r => r.json()).catch(() => ({})),
  fetch("sim_results.json").then(r => r.json()).catch(() => []),
]).then(([gamesMap, teamsArr, scheduleMap, simResults]) => {
  const games = gamesMap[teamAbbr];
  if (!games || games.length === 0) {
    document.getElementById("teamName").textContent = `No data for "${teamAbbr}"`;
    return;
  }

  const teamInfo = teamsArr.find(t => t.team_abbr === teamAbbr) || {};
  TEAM_INFO = teamInfo;
  ALL_TEAMS = {};
  teamsArr.forEach(t => { ALL_TEAMS[t.team_abbr] = t; });
  SIM_TEAM = simResults.find(t => t.team_abbr === teamAbbr) || null;
  const teamName = games[0].team_displayName || teamAbbr;
  const mIcon = teamInfo.momentum_l5 >= 90 ? " üî•" : teamInfo.momentum_l5 <= 10 ? " ‚ùÑÔ∏è" : "";
  document.getElementById("teamName").textContent = teamName + mIcon;
  document.title = `${teamName} ‚Äî CBB Ratings 2025-26`;

  // compute record
  let wins = 0, losses = 0;
  games.forEach(g => {
    if (g.points > g.points_allowed) wins++;
    else if (g.points < g.points_allowed) losses++;
  });
  document.getElementById("record").textContent = `${wins}-${losses}`;

  // summary chips
    const chips = [
      { label: "Conf", val: teamInfo.conference ? `<a href="conference.html?conf=${encodeURIComponent(teamInfo.conference)}" style="color:var(--accent);text-decoration:none">${teamInfo.conference}</a>` : "‚Äì", raw: true },
      { label: "Games", val: games.length },
      { label: "Adj T", val: teamInfo.Tempo_srs?.toFixed(1) ?? "‚Äì" },
      { label: "Adj OE", val: teamInfo.OffEff_srs?.toFixed(2) ?? "‚Äì" },
      { label: "Adj DE", val: teamInfo.DefEff_srs?.toFixed(2) ?? "‚Äì" },
      { label: "Total AdjE", val: teamInfo.net_srs != null ? (teamInfo.net_srs >= 0 ? "+" : "") + teamInfo.net_srs.toFixed(2) : "‚Äì" },
      { label: "SOS", val: teamInfo.sos != null ? (teamInfo.sos >= 0 ? "+" : "") + teamInfo.sos.toFixed(2) : "‚Äì" },
      { label: "SOS Rk", val: teamInfo.rank_sos ?? "‚Äì" },
      { label: "NC SOS", val: teamInfo.nc_sos != null ? (teamInfo.nc_sos >= 0 ? "+" : "") + teamInfo.nc_sos.toFixed(2) : "‚Äì" },
      { label: "NC SOS Rk", val: teamInfo.rank_nc_sos ?? "‚Äì" },
      { label: "Q1", val: teamInfo.q1_record ?? "‚Äì" },
      { label: "Q2", val: teamInfo.q2_record ?? "‚Äì" },
      { label: "Q3", val: teamInfo.q3_record ?? "‚Äì" },
      { label: "Q4", val: teamInfo.q4_record ?? "‚Äì" },
      { label: "Streak", val: teamInfo.streak ? `<span class="${teamInfo.streak[0] === 'W' ? 'net-pos' : 'net-neg'}">${teamInfo.streak}</span>` : "‚Äì", raw: true },
    ];
    document.getElementById("summary").innerHTML = chips.map(c =>
      `<div class="chip">${c.label}: <span class="val">${c.raw ? c.val : c.val}</span></div>`
    ).join("");

  // ---- Ensure all games have advanced stats before splits ----
  games.forEach(g => {
    // Only fill if not already present
    const fgm = Math.round(g.fieldGoals_made ?? 0);
    const fga = Math.round(g.fieldGoals_attempted ?? 0);
    const tpm = Math.round(g.threePointFieldGoals_made ?? 0);
    const tpa = Math.round(g.threePointFieldGoals_attempted ?? 0);
    const ftm = Math.round(g.freeThrows_made ?? 0);
    const fta = Math.round(g.freeThrows_attempted ?? 0);
    const oReb = g.offensiveRebounds ?? 0;
    const dReb = g.defensiveRebounds ?? 0;
    const oppOReb = g.opp_offReb ?? 0;
    const oppDReb = g.opp_defReb ?? 0;
    const poss = g.possessions ?? 0;
    const oppPoss = g.opp_possessions ?? 0;
    const to = g.turnovers ?? 0;
    const oppTO = g.opp_turnovers ?? 0;
    const ast = g.assists ?? 0;
    // OR% = Off Rebs / (Off Rebs + Opp Def Rebs)
    const orDenom = oReb + oppDReb;
    g._or_pct = orDenom ? (oReb / orDenom * 100).toFixed(1) : "‚Äì";
    // DR% = Def Rebs / (Def Rebs + Opp Off Rebs)
    const drDenom = dReb + oppOReb;
    g._dr_pct = drDenom ? (dReb / drDenom * 100).toFixed(1) : "‚Äì";
    // Off TO% = TO / Possessions
    g._off_to_pct = poss ? (to / poss * 100).toFixed(1) : "‚Äì";
    // Def TO% = Opp TO / Opp Possessions
    g._def_to_pct = oppPoss ? (oppTO / oppPoss * 100).toFixed(1) : "‚Äì";
    // AST Rate = AST / FGM
    g._ast_rate = fgm ? (ast / fgm * 100).toFixed(1) : "‚Äì";
    // eFG% = (FGM + 0.5 * 3PM) / FGA
    g._efg_pct = fga ? ((fgm + 0.5 * tpm) / fga * 100).toFixed(1) : "‚Äì";
    // FTR = FTA / FGA
    g._ftr = fga ? (fta / fga * 100).toFixed(1) : "‚Äì";
    // 3PT% = 3PM / 3PA
    g._3pt_pct = tpa ? (tpm / tpa * 100).toFixed(1) : "‚Äì";
  });

  // Add advanced stats fields to splits
  const advFields = [
    '_efg_pct', '_3pt_pct', '_ftr', '_or_pct', '_dr_pct', '_off_to_pct', '_def_to_pct', '_ast_rate',
    'OffEff_game_adj', 'DefEff_game_adj'
  ];
  const splits = {
    home: { w:0, l:0, pts:0, pa:0, adjE:[], count:0 },
    away: { w:0, l:0, pts:0, pa:0, adjE:[], count:0 },
    neutral: { w:0, l:0, pts:0, pa:0, adjE:[], count:0 }
  };
  for (const loc of Object.keys(splits)) {
    for (const f of advFields) splits[loc][f] = [];
  }
  games.forEach(g => {
    const loc = g.homeAway === "home" ? "home" : g.homeAway === "away" ? "away" : "neutral";
    const s = splits[loc];
    if (g.points > g.points_allowed) s.w++; else s.l++;
    s.pts += g.points || 0;
    s.pa += g.points_allowed || 0;
    const gAdjE = (g.OffEff_game_adj != null && g.DefEff_game_adj != null) ? g.OffEff_game_adj - g.DefEff_game_adj : null;
    if (gAdjE != null) s.adjE.push(gAdjE);
    for (const f of advFields) {
      let v = g[f];
      if (v !== undefined && v !== null && v !== "‚Äì" && !isNaN(Number(v))) s[f].push(Number(v));
    }
    s.count++;
  });

  function avg(arr, digits=1) {
    if (!arr.length) return "‚Äì";
    const v = arr.reduce((a,b) => a+b, 0) / arr.length;
    return v.toFixed(digits);
  }
  function splitRow(label, s) {
    const gp = s.w + s.l;
    if (gp === 0) return "";
    const record = `${s.w}-${s.l}`;
    const ppg = (s.pts / gp).toFixed(1);
    const oppPpg = (s.pa / gp).toFixed(1);
    const margin = ((s.pts - s.pa) / gp).toFixed(1);
    const marginCls = margin > 0 ? "net-pos" : margin < 0 ? "net-neg" : "";
    const avgAdjE = s.adjE.length ? (s.adjE.reduce((a,b) => a+b, 0) / s.adjE.length).toFixed(2) : "‚Äì";
    const adjECls = avgAdjE !== "‚Äì" ? (parseFloat(avgAdjE) > 0 ? "net-pos" : parseFloat(avgAdjE) < 0 ? "net-neg" : "") : "";
    const adjEFmt = avgAdjE !== "‚Äì" ? (parseFloat(avgAdjE) >= 0 ? "+" : "") + avgAdjE : "‚Äì";
    // Advanced stats
    const efg = avg(s._efg_pct);
    const tpct = avg(s._3pt_pct);
    const ftr = avg(s._ftr);
    const orp = avg(s._or_pct);
    const drp = avg(s._dr_pct);
    const oto = avg(s._off_to_pct);
    const dto = avg(s._def_to_pct);
    const ast = avg(s._ast_rate);
    const oeff = avg(s.OffEff_game_adj, 1);
    const deff = avg(s.DefEff_game_adj, 1);
    return `<tr>
      <td>${label}</td>
      <td>${record}</td>
      <td>${ppg}</td>
      <td>${oppPpg}</td>
      <td class="${marginCls}">${margin > 0 ? "+" : ""}${margin}</td>
      <td class="${adjECls}">${adjEFmt}</td>
      <td>${efg}</td>
      <td>${tpct}</td>
      <td>${ftr}</td>
      <td>${orp}</td>
      <td>${drp}</td>
      <td>${oto}</td>
      <td>${dto}</td>
      <td>${ast}</td>
      <td>${oeff}</td>
      <td>${deff}</td>
    </tr>`;
  }


  document.getElementById("splitsWrap").innerHTML = `
    <h3>Home / Away / Neutral Splits</h3>
    <div style="overflow-x:auto">
    <table class="splits-table">
      <thead><tr>
        <th>Location</th><th>Record</th><th>PPG</th><th>Opp PPG</th><th>Margin</th><th>Avg AdjE</th>
        <th>eFG%</th><th>3PT%</th><th>FTR</th><th>OR%</th><th>DR%</th><th>Off TO%</th><th>Def TO%</th><th>AST Rate</th><th>Adj OE</th><th>Adj DE</th>
      </tr></thead>
      <tbody>
        ${splitRow("üè† Home", splits.home)}
        ${splitRow("‚úàÔ∏è Away", splits.away)}
        ${splitRow("üìç Neutral", splits.neutral)}
      </tbody>
    </table>
    </div>
  `;

  // compute cumulative WAB (games arrive sorted oldest-first)
  let cumWab = 0;
  games.forEach(g => {
    if (g.wab != null) { cumWab += g.wab; }
    g._cum_wab = Math.round(cumWab * 1000) / 1000;
  });

  // most-recent first & pre-compute all derived fields
  games.reverse();
  games.forEach(g => {
    g._loc = g.homeAway === "home" ? "Home" : g.homeAway === "away" ? "Away" : "Neutral";
    const won = g.points > g.points_allowed;
    g._won = won;
    g._result = `${won ? "W" : "L"} ${Math.round(g.points)}-${Math.round(g.points_allowed)}`;

    const fgm = Math.round(g.fieldGoals_made ?? 0);
    const fga = Math.round(g.fieldGoals_attempted ?? 0);
    g._fg = `${fgm}/${fga}`;
    g._fg_pct = fga ? (fgm / fga * 100).toFixed(1) : "‚Äì";

    const tpm = Math.round(g.threePointFieldGoals_made ?? 0);
    const tpa = Math.round(g.threePointFieldGoals_attempted ?? 0);
    g._3fg = `${tpm}/${tpa}`;
    g._3fg_pct = tpa ? (tpm / tpa * 100).toFixed(1) : "‚Äì";

    const ftm = Math.round(g.freeThrows_made ?? 0);
    const fta = Math.round(g.freeThrows_attempted ?? 0);
    g._ft = `${ftm}/${fta}`;
    g._ft_pct = fta ? (ftm / fta * 100).toFixed(1) : "‚Äì";

    // ---- advanced stats ----
    const oReb = g.offensiveRebounds ?? 0;
    const dReb = g.defensiveRebounds ?? 0;
    const oppOReb = g.opp_offReb ?? 0;
    const oppDReb = g.opp_defReb ?? 0;
    const poss = g.possessions ?? 0;
    const oppPoss = g.opp_possessions ?? 0;
    const to = g.turnovers ?? 0;
    const oppTO = g.opp_turnovers ?? 0;
    const ast = g.assists ?? 0;

    // OR% = Off Rebs / (Off Rebs + Opp Def Rebs)
    const orDenom = oReb + oppDReb;
    g._or_pct = orDenom ? (oReb / orDenom * 100).toFixed(1) : "‚Äì";
    // DR% = Def Rebs / (Def Rebs + Opp Off Rebs)
    const drDenom = dReb + oppOReb;
    g._dr_pct = drDenom ? (dReb / drDenom * 100).toFixed(1) : "‚Äì";
    // Off TO% = TO / Possessions
    g._off_to_pct = poss ? (to / poss * 100).toFixed(1) : "‚Äì";
    // Def TO% = Opp TO / Opp Possessions
    g._def_to_pct = oppPoss ? (oppTO / oppPoss * 100).toFixed(1) : "‚Äì";
    // AST Rate = AST / FGM
    g._ast_rate = fgm ? (ast / fgm * 100).toFixed(1) : "‚Äì";
    // eFG% = (FGM + 0.5 * 3PM) / FGA
    g._efg_pct = fga ? ((fgm + 0.5 * tpm) / fga * 100).toFixed(1) : "‚Äì";
    // FTR = FTA / FGA
    g._ftr = fga ? (fta / fga * 100).toFixed(1) : "‚Äì";
    // Pts Off TO %, Fast Break %, Pts In Paint % ‚Äî as share of total points
    const pts = g.points ?? 0;
    g._to_pts_pct  = pts ? ((g.turnoverPoints ?? 0)  / pts * 100).toFixed(1) : "‚Äì";
    g._fb_pts_pct  = pts ? ((g.fastBreakPoints ?? 0) / pts * 100).toFixed(1) : "‚Äì";
    g._pip_pct     = pts ? ((g.pointsInPaint ?? 0)   / pts * 100).toFixed(1) : "‚Äì";
    // 3PT Rate = 3PA / FGA
    g._3pt_rate    = fga ? (tpa / fga * 100).toFixed(1) : "‚Äì";
    // 3PT% = 3PM / 3PA
    g._3pt_pct     = tpa ? (tpm / tpa * 100).toFixed(1) : "‚Äì";
    // FT% = FTM / FTA
    g._ft_pct      = fta ? (ftm / fta * 100).toFixed(1) : "‚Äì";
    // STL% = Steals / Opp Possessions
    g._stl_pct     = oppPoss ? ((g.steals ?? 0) / oppPoss * 100).toFixed(1) : "‚Äì";
    // BLK% = Blocks / Opp FGA
    const oppFga = g.opp_fga ?? 0;
    g._blk_pct     = oppFga ? ((g.blocks ?? 0) / oppFga * 100).toFixed(1) : "‚Äì";

    // ---- opponent (defensive) stats ----
    const oFgm = Math.round(g.opp_fgm ?? 0);
    const oFga = Math.round(g.opp_fga ?? 0);
    const oTpm = Math.round(g.opp_3pm ?? 0);
    const oTpa = Math.round(g.opp_3pa ?? 0);
    const oFtm = Math.round(g.opp_ftm ?? 0);
    const oFta = Math.round(g.opp_fta ?? 0);
    const oAst = g.opp_ast ?? 0;
    const oStl = g.opp_stl ?? 0;
    const oBlk = g.opp_blk ?? 0;
    const oPoss = g.opp_poss_calc ?? oppPoss;
    const oPts = g.opp_pts ?? g.points_allowed ?? 0;

    // Opp eFG%
    g._opp_efg_pct = oFga ? ((oFgm + 0.5 * oTpm) / oFga * 100).toFixed(1) : "‚Äì";
    // Opp 3PT Rate
    g._opp_3pt_rate = oFga ? (oTpa / oFga * 100).toFixed(1) : "‚Äì";
    // Opp 3PT%
    g._opp_3pt_pct = oTpa ? (oTpm / oTpa * 100).toFixed(1) : "‚Äì";
    // Opp FTR
    g._opp_ftr = oFga ? (oFta / oFga * 100).toFixed(1) : "‚Äì";
    // Opp FT%
    g._opp_ft_pct = oFta ? (oFtm / oFta * 100).toFixed(1) : "‚Äì";
    // Opp AST Rate
    g._opp_ast_rate = oFgm ? (oAst / oFgm * 100).toFixed(1) : "‚Äì";
    // Opp OR% = Opp Off Rebs / (Opp Off Rebs + Team Def Rebs)
    const oppOrDenom = oppOReb + dReb;
    g._opp_or_pct = oppOrDenom ? (oppOReb / oppOrDenom * 100).toFixed(1) : "‚Äì";
    // Opp DR% = Opp Def Rebs / (Opp Def Rebs + Team Off Rebs)
    const oppDrDenom = oppDReb + oReb;
    g._opp_dr_pct = oppDrDenom ? (oppDReb / oppDrDenom * 100).toFixed(1) : "‚Äì";
    // Opp Off TO%
    g._opp_off_to_pct = oPoss ? (oppTO / oPoss * 100).toFixed(1) : "‚Äì";
    // Opp STL% = Opp Steals / Team Possessions
    g._opp_stl_pct = poss ? (oStl / poss * 100).toFixed(1) : "‚Äì";
    // Opp BLK% = Opp Blocks / Team FGA
    g._opp_blk_pct = fga ? (oBlk / fga * 100).toFixed(1) : "‚Äì";
    // Opp Scoring Breakdown (share of opponent's total points)
    g._opp_to_pts_pct  = oPts ? ((g.opp_turnoverPoints ?? 0)  / oPts * 100).toFixed(1) : "‚Äì";
    g._opp_fb_pts_pct  = oPts ? ((g.opp_fastBreakPoints ?? 0) / oPts * 100).toFixed(1) : "‚Äì";
    g._opp_pip_pct     = oPts ? ((g.opp_pointsInPaint ?? 0)   / oPts * 100).toFixed(1) : "‚Äì";
  });

  GAMES = games;
  renderTable();

  // sub-tab switching (Box Score / Offensive / Defensive)
  function switchSubTab(view) {
    gtag('event', 'tab_click', { event_category: 'navigation', event_label: 'sub_' + view, page: 'team' });
    activeView = view;
    document.querySelectorAll(".sub-tab-btn").forEach(b => b.classList.remove("active"));
    if (view === "box") document.getElementById("subLog").classList.add("active");
    else if (view === "off") document.getElementById("subOff").classList.add("active");
    else document.getElementById("subDef").classList.add("active");
    renderTable();
  }
  document.getElementById("subLog").addEventListener("click", () => switchSubTab("box"));
  document.getElementById("subOff").addEventListener("click", () => switchSubTab("off"));
  document.getElementById("subDef").addEventListener("click", () => switchSubTab("def"));

  // ---- Future Schedule rendering ----
  // what-if state: { 0: "win"|"loss", 1: "win"|"loss", ... }
  const whatifSelections = {};
  const MAX_LOSSES = 15;   // teams with ‚â• this many total losses cannot make the tournament

  function computeWabForGame(oppSrs, homeAway, bubbleEM) {
    const K_WAB = 0.17, HOME_ADV_WAB = 3.0, AVG_POSS = 68.9;
    let locAdj = 0;
    if (homeAway === "home") locAdj = HOME_ADV_WAB;
    else if (homeAway === "away") locAdj = -HOME_ADV_WAB;
    const dBubble = bubbleEM - oppSrs + locAdj;
    const mBubble = dBubble * (AVG_POSS / 100.0);
    const pBubble = 1.0 / (1.0 + Math.exp(-K_WAB * mBubble));
    return { wabWin: 1.0 - pBubble, wabLoss: 0.0 - pBubble };
  }

  function updateWhatIf() {
    const futureGames = scheduleMap[teamAbbr] || [];
    if (futureGames.length === 0 || !SIM_TEAM) {
      document.getElementById("whatifWrap").style.display = "none";
      return;
    }

    // Count selections
    let selectedWins = 0, selectedLosses = 0;
    const K_WAB = 0.17, HOME_ADV_WAB = 3.0, AVG_POSS = 68.9;
    const allTeamArr = Object.values(ALL_TEAMS);
    const sortedSrs = allTeamArr.map(t => t.net_srs).filter(v => v != null).sort((a, b) => b - a);
    const bubbleSlice = sortedSrs.slice(34, 55);
    const bubbleEM = bubbleSlice.length ? bubbleSlice.reduce((s, v) => s + v, 0) / bubbleSlice.length : 0;

    let deltaWab = 0;
    futureGames.forEach((g, i) => {
      if (whatifSelections[i] === "win") {
        selectedWins++;
        const opp = ALL_TEAMS[g.opp_abbr];
        if (opp?.net_srs != null) {
          const { wabWin } = computeWabForGame(opp.net_srs, g.homeAway, bubbleEM);
          deltaWab += wabWin;
        }
      } else if (whatifSelections[i] === "loss") {
        selectedLosses++;
        const opp = ALL_TEAMS[g.opp_abbr];
        if (opp?.net_srs != null) {
          const { wabLoss } = computeWabForGame(opp.net_srs, g.homeAway, bubbleEM);
          deltaWab += wabLoss;
        }
      }
    });

    const totalGames = futureGames.length;
    const unselected = totalGames - selectedWins - selectedLosses;

    // Current stats
    const currentWins = wins;
    const currentLosses = losses;
    const currentWab = TEAM_INFO.season_wab ?? 0;
    const currentMakePct = SIM_TEAM.make_pct ?? 0;
    const currentSeed = SIM_TEAM.avg_seed_if_make ?? null;

    const projWins = currentWins + selectedWins;
    const projLosses = currentLosses + selectedLosses;
    const projWab = currentWab + deltaWab;

    // Record card
    const recEl = document.getElementById("wiRecord");
    const recSubEl = document.getElementById("wiRecordSub");
    if (selectedWins + selectedLosses > 0) {
      recEl.textContent = `${projWins}-${projLosses}`;
      recSubEl.textContent = unselected > 0 ? `(${unselected} game${unselected > 1 ? "s" : ""} unselected)` : "";
    } else {
      recEl.textContent = `${currentWins}-${currentLosses}`;
      recSubEl.textContent = "(select games below)";
    }

    // ---- Weighted projection across seed_by_losses buckets ----
    // The user has locked in `selectedLosses` losses from selected games.
    // There are `unselected` games whose outcomes are unknown.
    // The final total losses = selectedLosses + (extra losses from unselected games).
    // We weight each eligible bucket using the sim's own distribution,
    // applying binomial coefficients for the unselected portion.
    //
    // Additionally, we adjust for *which* games were won/lost by computing a
    // WAB residual: the difference between the user's actual WAB delta and
    // the average WAB delta expected for that win/loss count. This residual
    // shifts the effective loss count fractionally between buckets.
    const sbl = SIM_TEAM.seed_by_losses || [];

    // Compute average WAB-with-win and WAB-with-loss across all future games
    let avgWabWin = 0, avgWabLoss = 0, wabCount = 0;
    futureGames.forEach(g => {
      const opp = ALL_TEAMS[g.opp_abbr];
      if (opp?.net_srs != null) {
        const { wabWin: wW, wabLoss: wL } = computeWabForGame(opp.net_srs, g.homeAway, bubbleEM);
        avgWabWin += wW;
        avgWabLoss += wL;
        wabCount++;
      }
    });
    if (wabCount > 0) { avgWabWin /= wabCount; avgWabLoss /= wabCount; }

    // Expected WAB delta if user's selected W/L hit average opponents
    const expectedDeltaWab = selectedWins * avgWabWin + selectedLosses * avgWabLoss;
    // WAB residual: positive = user's picks are better than average, negative = worse
    const wabResidual = deltaWab - expectedDeltaWab;
    // Convert residual to a fractional loss shift:
    // One "loss unit" of WAB difference ‚âà avgWabWin - avgWabLoss (the WAB swing of flipping a W to an L)
    const wabSwing = (avgWabWin - avgWabLoss) || 1;
    // A positive residual (better WAB) should shift toward fewer losses (negative shift)
    const lossShift = -wabResidual / wabSwing;

    // Derive per-game loss probability from the sim distribution
    const totalSims = sbl.reduce((s, b) => s + b.sims, 0);
    const expectedLosses = totalSims > 0 ? sbl.reduce((s, b) => s + b.losses * b.sims, 0) / totalSims : 0;
    const pLoss = totalGames > 0 ? Math.min(Math.max(expectedLosses / totalGames, 0.01), 0.99) : 0.5;
    const pWin = 1 - pLoss;

    // Binomial coefficient C(n,k)
    function binom(n, k) {
      if (k < 0 || k > n) return 0;
      if (k === 0 || k === n) return 1;
      let r = 1;
      for (let i = 0; i < k; i++) r = r * (n - i) / (i + 1);
      return r;
    }

    // Helper: compute weighted make_pct and avg_seed for a given (possibly fractional) loss base
    // tL is *future* losses; total losses = currentLosses + tL
    // If total losses >= MAX_LOSSES, force make_pct to 0 for that bucket.
    function weightedProjection(baseLosses) {
      let wMake = 0, wSeed = 0, wSeedW = 0, wTotal = 0;
      for (let j = 0; j <= unselected; j++) {
        const tL = baseLosses + j;

        // Hard cap: if total losses (current + future) >= MAX_LOSSES, this
        // bucket is ineligible regardless of what seed_by_losses says.
        const totalLosses = currentLosses + tL;
        if (totalLosses >= MAX_LOSSES) {
          // Count this bucket weight but contribute 0% make
          const bw = binom(unselected, j) * Math.pow(pLoss, j) * Math.pow(pWin, unselected - j);
          wTotal += bw;
          // wMake += 0
          continue;
        }

        // For fractional baseLosses, interpolate between floor and ceil buckets
        const lo = Math.floor(tL), hi = Math.ceil(tL);
        const frac = tL - lo;
        const bLo = sbl.find(b => b.losses === lo);
        const bHi = lo === hi ? bLo : sbl.find(b => b.losses === hi);

        const bw = binom(unselected, j) * Math.pow(pLoss, j) * Math.pow(pWin, unselected - j);
        if (!bLo && !bHi) continue;

        // Interpolated make_pct
        const mLo = bLo ? bLo.make_pct : (bHi ? bHi.make_pct : 0);
        const mHi = bHi ? bHi.make_pct : (bLo ? bLo.make_pct : 0);
        const mInterp = mLo + frac * (mHi - mLo);

        wTotal += bw;
        wMake += bw * mInterp;

        // Interpolated avg_seed
        const sLo = bLo?.avg_seed, sHi = bHi?.avg_seed;
        if (sLo != null || sHi != null) {
          const s1 = sLo ?? sHi, s2 = sHi ?? sLo;
          const sInterp = s1 + frac * (s2 - s1);
          wSeed += bw * sInterp;
          wSeedW += bw;
        }
      }
      return {
        make: wTotal > 0 ? wMake / wTotal : null,
        seed: wSeedW > 0 ? wSeed / wSeedW : null
      };
    }

    // Effective base losses = selectedLosses + WAB-driven fractional shift
    // Clamp so we don't go below 0 or above totalGames
    const effectiveLosses = Math.max(0, Math.min(totalGames, selectedLosses + lossShift));
    const proj = weightedProjection(effectiveLosses);
    // Hard override: if the user's selected losses already push total ‚â• MAX_LOSSES,
    // tournament odds are 0 regardless of WAB residual / interpolation.
    const projMake = (currentLosses + selectedLosses >= MAX_LOSSES) ? 0 : proj.make;
    const projSeed = (currentLosses + selectedLosses >= MAX_LOSSES) ? null : proj.seed;

    // Tournament odds card
    const makeEl = document.getElementById("wiMakePct");
    const makeDEl = document.getElementById("wiMakeDelta");
    if (projMake != null && (selectedWins + selectedLosses > 0)) {
      makeEl.textContent = projMake.toFixed(1) + "%";
      const dMake = projMake - currentMakePct;
      if (Math.abs(dMake) < 0.05) {
        makeDEl.textContent = "No change";
        makeDEl.className = "wc-delta flat";
      } else {
        makeDEl.textContent = (dMake > 0 ? "‚ñ≤ +" : "‚ñº ") + dMake.toFixed(1) + "%";
        makeDEl.className = "wc-delta " + (dMake > 0 ? "up" : "down");
      }
    } else if (selectedWins + selectedLosses > 0) {
      makeEl.textContent = "N/A";
      makeDEl.textContent = "No sim data for this scenario";
      makeDEl.className = "wc-delta flat";
    } else {
      makeEl.textContent = currentMakePct.toFixed(1) + "%";
      makeDEl.textContent = "Current";
      makeDEl.className = "wc-delta flat";
    }

    // Seed card
    const seedEl = document.getElementById("wiSeed");
    const seedDEl = document.getElementById("wiSeedDelta");
    if (projSeed != null && (selectedWins + selectedLosses > 0)) {
      seedEl.textContent = projSeed.toFixed(1);
      if (currentSeed != null) {
        const dSeed = projSeed - currentSeed;
        if (Math.abs(dSeed) < 0.05) {
          seedDEl.textContent = "No change";
          seedDEl.className = "wc-delta flat";
        } else {
          seedDEl.textContent = (dSeed < 0 ? "‚ñ≤ " : "‚ñº +") + dSeed.toFixed(1);
          seedDEl.className = "wc-delta " + (dSeed < 0 ? "up" : "down");
        }
      } else {
        seedDEl.textContent = "";
        seedDEl.className = "wc-delta";
      }
    } else if (selectedWins + selectedLosses > 0) {
      seedEl.textContent = "N/A";
      seedDEl.textContent = "No sim data for this scenario";
      seedDEl.className = "wc-delta flat";
    } else {
      seedEl.textContent = currentSeed != null ? currentSeed.toFixed(1) : "‚Äì";
      seedDEl.textContent = "Current";
      seedDEl.className = "wc-delta flat";
    }

    // WAB card
    const wabEl = document.getElementById("wiWab");
    const wabDEl = document.getElementById("wiWabDelta");
    if (selectedWins + selectedLosses > 0) {
      wabEl.textContent = (projWab >= 0 ? "+" : "") + projWab.toFixed(2);
      const dWab = deltaWab;
      if (Math.abs(dWab) < 0.005) {
        wabDEl.textContent = "No change";
        wabDEl.className = "wc-delta flat";
      } else {
        wabDEl.textContent = (dWab > 0 ? "‚ñ≤ +" : "‚ñº ") + dWab.toFixed(2);
        wabDEl.className = "wc-delta " + (dWab > 0 ? "up" : "down");
      }
    } else {
      wabEl.textContent = (currentWab >= 0 ? "+" : "") + currentWab.toFixed(2);
      wabDEl.textContent = "Current";
      wabDEl.className = "wc-delta flat";
    }
  }

  function renderSchedule() {
    const futureGames = scheduleMap[teamAbbr] || [];
    const thead = document.getElementById("schedHead");
    const tbody = document.getElementById("schedBody");

    if (futureGames.length === 0) {
      thead.innerHTML = "";
      tbody.innerHTML = `<tr><td colspan="10" style="text-align:center;padding:24px;color:var(--text-dim)">No upcoming games found</td></tr>`;
      document.getElementById("whatifWrap").style.display = "none";
      return;
    }

    // WAB constants (mirrors build_site.py)
    const K_WAB = 0.17;
    const HOME_ADV_WAB = 3.0;
    const AVG_POSS = 68.9;

    // Compute bubble EM: average net_srs of teams ranked 35-55 by net_srs
    const allTeamArr = Object.values(ALL_TEAMS);
    const sortedSrs = allTeamArr.map(t => t.net_srs).filter(v => v != null).sort((a, b) => b - a);
    const bubbleSlice = sortedSrs.slice(34, 55); // 0-indexed: ranks 35-55
    const bubbleEM = bubbleSlice.length ? bubbleSlice.reduce((s, v) => s + v, 0) / bubbleSlice.length : 0;

    // Team's own AdjE
    const teamAdjE = TEAM_INFO.net_srs ?? 0;

    thead.innerHTML = `<tr>
      <th style="text-align:center;width:60px">Result</th>
      <th style="text-align:left">Date</th>
      <th style="text-align:left">Opponent</th>
      <th>Opp AdjE Rk</th>
      <th>Opp AdjE</th>
      <th>Loc</th>
      <th>Proj Quad</th>
      <th style="text-align:left">Projected Score</th>
      <th>WAB w/ Win</th>
      <th>WAB w/ Loss</th>
    </tr>`;

    const rows = futureGames.map((g, idx) => {
      // Cross-reference opponent stats
      const opp = ALL_TEAMS[g.opp_abbr];
      const oppRank = opp?.rank_net ?? "‚Äì";
      const oppAdjE = opp?.net_srs != null ? (opp.net_srs >= 0 ? "+" : "") + opp.net_srs.toFixed(2) : "‚Äì";
      const adjECls = opp?.net_srs != null ? (opp.net_srs > 0 ? "net-pos" : opp.net_srs < 0 ? "net-neg" : "") : "";
      const oppSrs = opp?.net_srs;

      // Location display
      const loc = g.neutralSite ? "N" : g.homeAway === "home" ? "Home" : g.homeAway === "away" ? "Away" : "‚Äì";

      // Projected quad based on opponent NET rank + location
      let quad = "‚Äì";
      if (typeof oppRank === "number") {
        if (g.homeAway === "home" || g.neutralSite) {
          if (oppRank <= 30) quad = 1;
          else if (oppRank <= 75) quad = 2;
          else if (oppRank <= 160) quad = 3;
          else quad = 4;
        } else {
          if (oppRank <= 75) quad = 1;
          else if (oppRank <= 135) quad = 2;
          else if (oppRank <= 260) quad = 3;
          else quad = 4;
        }
      }
      const quadCls = quad !== "‚Äì" ? `quad-${quad}` : "";
      const quadDisp = quad !== "‚Äì" ? `Q${quad}` : "‚Äì";

      // Opponent link
      const oppLink = g.opp_abbr
        ? `<a href="team.html?team=${encodeURIComponent(g.opp_abbr)}" style="color:var(--accent);text-decoration:none">${g.opp_displayName || g.opp_abbr}</a>`
        : (g.opp_displayName || "‚Äì");

      // Format date nicely
      const dParts = g.date ? g.date.split("-") : [];
      const dateDisp = dParts.length === 3
        ? `${parseInt(dParts[1])}/${parseInt(dParts[2])}`
        : g.date || "‚Äì";
      const timeDisp = g.time_detail || "";
      const dateLinkText = timeDisp ? `${dateDisp} <span style="color:var(--text-dim);font-size:.75rem">${timeDisp.replace(/^[^-]+-\s*/, "")}</span>` : dateDisp;
      const dateCell = g.date
        ? `<a href="game_date.html?date=${encodeURIComponent(g.date)}" style="color:var(--accent);text-decoration:none">${dateLinkText}</a>`
        : dateLinkText;

      // ---- Projected Score ----
      let expectedStr = "‚Äì";
      const teamOE = TEAM_INFO.OffEff_srs, teamDE = TEAM_INFO.DefEff_srs, teamT = TEAM_INFO.Tempo_srs;
      const oppOE = opp?.OffEff_srs, oppDE = opp?.DefEff_srs, oppT = opp?.Tempo_srs;
      if (teamOE != null && teamDE != null && oppOE != null && oppDE != null && teamT != null && oppT != null) {
        const poss = teamT * oppT / AVG_POSS;
        let adjTeamOE = teamOE, adjOppOE = oppOE;
        if (g.homeAway === "home") { adjTeamOE += HOME_ADV_WAB / 2; adjOppOE -= HOME_ADV_WAB / 2; }
        else if (g.homeAway === "away") { adjTeamOE -= HOME_ADV_WAB / 2; adjOppOE += HOME_ADV_WAB / 2; }
        const teamProjPtsRaw = adjTeamOE * oppDE / 100 * poss / 100;
        const oppProjPtsRaw  = adjOppOE * teamDE / 100 * poss / 100;
        let teamProjPts = Math.round(teamProjPtsRaw);
        let oppProjPts  = Math.round(oppProjPtsRaw);
        /* break ties: bump the team with the higher raw score */
        if (teamProjPts === oppProjPts) {
          if (teamProjPtsRaw >= oppProjPtsRaw) teamProjPts += 1;
          else oppProjPts += 1;
        }
        const teamName = TEAM_INFO.team_displayName || teamAbbr;
        const oppName = g.opp_displayName || g.opp_abbr;
        const projFav = teamProjPts >= oppProjPts ? teamName : oppName;
        const projHi  = Math.max(teamProjPts, oppProjPts);
        const projLo  = Math.min(teamProjPts, oppProjPts);
        expectedStr = `${projFav} ${projHi} - ${projLo}`;
      }

      // ---- WAB w/ Win and WAB w/ Loss ----
      let wabWin = "‚Äì", wabLoss = "‚Äì", wabWinCls = "", wabLossCls = "";
      if (oppSrs != null) {
        const { wabWin: wW, wabLoss: wL } = computeWabForGame(oppSrs, g.homeAway, bubbleEM);
        wabWin = (wW >= 0 ? "+" : "") + wW.toFixed(3);
        wabLoss = (wL >= 0 ? "+" : "") + wL.toFixed(3);
        wabWinCls = wW > 0 ? "net-pos" : wW < 0 ? "net-neg" : "";
        wabLossCls = wL > 0 ? "net-pos" : wL < 0 ? "net-neg" : "";
      }

      // Win/Loss toggle state
      const sel = whatifSelections[idx];
      const winCls = sel === "win" ? "sel-win" : "";
      const lossCls = sel === "loss" ? "sel-loss" : "";

      return `<tr>
        <td>
          <div class="wl-toggle">
            <button class="wl-btn ${winCls}" data-idx="${idx}" data-res="win">W</button>
            <button class="wl-btn ${lossCls}" data-idx="${idx}" data-res="loss">L</button>
          </div>
        </td>
        <td style="text-align:left">${dateCell}</td>
        <td style="text-align:left">${g.homeAway === "away" ? "@ " : ""}${oppLink}</td>
        <td>${oppRank}</td>
        <td class="${adjECls}">${oppAdjE}</td>
        <td>${loc}</td>
        <td class="${quadCls}">${quadDisp}</td>
        <td style="text-align:left">${expectedStr}</td>
        <td class="${wabWinCls}">${wabWin}</td>
        <td class="${wabLossCls}">${wabLoss}</td>
      </tr>`;
    });
    tbody.innerHTML = rows.join("");

    // Attach toggle listeners
    tbody.querySelectorAll(".wl-btn").forEach(btn => {
      btn.addEventListener("click", () => {
        const idx = parseInt(btn.dataset.idx);
        const res = btn.dataset.res;
        // Toggle: if already selected, deselect; otherwise select
        if (whatifSelections[idx] === res) {
          delete whatifSelections[idx];
        } else {
          whatifSelections[idx] = res;
        }
        // Update button visuals without full re-render
        const row = btn.closest("tr");
        row.querySelectorAll(".wl-btn").forEach(b => {
          b.classList.remove("sel-win", "sel-loss");
          if (whatifSelections[idx] === "win" && b.dataset.res === "win") b.classList.add("sel-win");
          if (whatifSelections[idx] === "loss" && b.dataset.res === "loss") b.classList.add("sel-loss");
        });
        updateWhatIf();
      });
    });

    updateWhatIf();
  }

  // Reset button
  document.getElementById("whatifReset").addEventListener("click", () => {
    Object.keys(whatifSelections).forEach(k => delete whatifSelections[k]);
    renderSchedule();
  });

  // tab switching
  function switchTab(tab) {
    gtag('event', 'tab_click', { event_category: 'navigation', event_label: tab, page: 'team' });
    document.querySelectorAll(".tab-btn").forEach(b => b.classList.remove("active"));
    document.getElementById("tab" + tab).classList.add("active");
    document.getElementById("subTabsWrap").style.display    = tab === "Log" ? "" : "none";
    document.getElementById("tableWrap").style.display      = tab === "Log" ? "" : "none";
    document.getElementById("scheduleWrap").style.display   = tab === "Sched" ? "" : "none";
    document.getElementById("whatifWrap").style.display      = tab === "Sched" ? "block" : "none";
    document.getElementById("simChartWrap").style.display   = tab === "Sched" ? "block" : "none";
    document.getElementById("wabChartWrap").style.display   = tab === "Wab" ? "block" : "none";
    document.getElementById("adjeChartWrap").style.display  = tab === "AdjE" ? "block" : "none";
    if (tab === "Sched") { renderSchedule(); renderSimChart(); }
    if (tab === "Wab")   renderWabChart();
    if (tab === "AdjE")  renderAdjEChart();
    localStorage.setItem("cbb_team_tab", tab);
  }
  document.getElementById("tabLog").addEventListener("click",   () => switchTab("Log"));
  document.getElementById("tabSched").addEventListener("click", () => switchTab("Sched"));
  document.getElementById("tabWab").addEventListener("click",   () => switchTab("Wab"));
  document.getElementById("tabAdjE").addEventListener("click",  () => switchTab("AdjE"));

  // Restore saved tab
  const savedTab = localStorage.getItem("cbb_team_tab");
  if (savedTab && ["Log","Sched","Wab","AdjE"].includes(savedTab) && savedTab !== "Log") {
    switchTab(savedTab);
  }

}).catch(e => {
  document.getElementById("teamName").textContent = `Error: ${e}`;
});

/* ---- heatmap helpers ---- */
function heatColor(val, min, max, invert) {
  if (val == null || min === max) return "";
  let t = (val - min) / (max - min);
  if (invert) t = 1 - t;
  // dark blue (13,27,42) ‚Üí light blue (88,166,255)
  const r = Math.round(13 + (88 - 13) * t);
  const g = Math.round(27 + (166 - 27) * t);
  const b = Math.round(42 + (255 - 42) * t);
  return `rgba(${r},${g},${b},0.25)`;
}

/* ---- render / re-render table ---- */
function renderTable() {
  const COLS = activeCols();

  // Build section header row for off/def views
  const thead = document.getElementById("headerRow").parentElement;
  thead.innerHTML = "";

  if (activeView === "off" || activeView === "def") {
    // section header row
    const sectionRow = document.createElement("tr");
    let spanCount = 0;
    const sections = [];
    COLS.forEach((c, i) => {
      if (c.section) {
        if (spanCount > 0 || sections.length === 0) {
          sections.push({ label: "", span: spanCount });
        }
        sections.push({ label: c.section, span: 0 });
        spanCount = 0;
      }
      // count columns for current section
      if (sections.length > 0) {
        sections[sections.length - 1].span++;
      } else {
        spanCount++;
      }
    });
    // any remaining cols without section
    if (spanCount > 0 && sections.length === 0) {
      sections.push({ label: "", span: spanCount });
    }

    // Build: shared cols (no section) + sections + EFF cols (no section)
    const sharedLen = SHARED_COLS.length;
    const effLen = EFF_COLS.length;
    const middleCols = activeView === "off" ? OFF_COLS : DEF_COLS;
    // Gather section spans from middle columns
    const sectionSpans = [];
    let curSection = null, curSpan = 0;
    middleCols.forEach(c => {
      if (c.section && c.section !== curSection) {
        if (curSection !== null) sectionSpans.push({ label: curSection, span: curSpan });
        curSection = c.section;
        curSpan = 0;
      }
      curSpan++;
    });
    if (curSection !== null) sectionSpans.push({ label: curSection, span: curSpan });

    // Shared blank header
    const blankTh = document.createElement("th");
    blankTh.setAttribute("colspan", sharedLen);
    blankTh.style.borderBottom = "none";
    sectionRow.appendChild(blankTh);
    // Section headers
    sectionSpans.forEach(s => {
      const th = document.createElement("th");
      th.setAttribute("colspan", s.span);
      th.className = "section-hdr";
      th.textContent = s.label;
      sectionRow.appendChild(th);
    });
    // Eff blank header
    const effTh = document.createElement("th");
    effTh.setAttribute("colspan", effLen);
    effTh.style.borderBottom = "none";
    sectionRow.appendChild(effTh);
    thead.appendChild(sectionRow);
  }

  // column header row
  const headerRow = document.createElement("tr");
  headerRow.id = "headerRow";
  COLS.forEach(c => {
    const th = document.createElement("th");
    th.innerHTML = c.label.replace(/\n/g, "<br>");
    th.style.textAlign = c.align || "center";
    if (c.narrow) th.classList.add("narrow-col");
    if (c.sectionStart) th.classList.add("section-start");
    if (c.sectionEnd) th.classList.add("section-end");
    headerRow.appendChild(th);
  });
  thead.appendChild(headerRow);

  // heatmap bounds
  const allOE = GAMES.map(g => g.OffEff_game_adj).filter(v => v != null);
  const allDE = GAMES.map(g => g.DefEff_game_adj).filter(v => v != null);
  const oeMin = Math.min(...allOE), oeMax = Math.max(...allOE);
  const deMin = Math.min(...allDE), deMax = Math.max(...allDE);

  // rows
  const tbody = document.getElementById("tbody");
  const frags = [];
  GAMES.forEach(g => {
    const cells = COLS.map(c => {
      const v = g[c.key];
      let display = c.fmt(v);
      let cls = "";
      let style = `text-align:${c.align || "center"};`;

      if (c.key === "_result") cls = g._won ? "win" : "loss";
      if (c.key === "quad" && v != null) cls += ` quad-${v}`;
      if (c.sectionStart) cls += " section-start";
      if (c.sectionEnd) cls += " section-end";

      if (c.key === "opp_team_displayName" && g.opp_team_abbr) {
        display = `<a href="team.html?team=${encodeURIComponent(g.opp_team_abbr)}" style="color:var(--accent);text-decoration:none">${display}</a>`;
      }

      if (c.key === "date" && g.date) {
        display = `<a href="game_date.html?date=${encodeURIComponent(g.date)}" style="color:var(--accent);text-decoration:none">${display}</a>`;
      }

      if (c.heatmap === "off") {
        const bg = heatColor(v, oeMin, oeMax, false);
        if (bg) style += `background:${bg};`;
        cls += " heatmap";
      } else if (c.heatmap === "def") {
        const bg = heatColor(v, deMin, deMax, true);
        if (bg) style += `background:${bg};`;
        cls += " heatmap";
      }

      return `<td style="${style}" class="${cls.trim()}">${display}</td>`;
    }).join("");
    frags.push(`<tr>${cells}</tr>`);
  });
  tbody.innerHTML = frags.join("");
}

/* ---- chart helpers ---- */
function setupCanvas(canvas) {
  const dpr = window.devicePixelRatio || 1;
  const rect = canvas.getBoundingClientRect();
  canvas.width = rect.width * dpr;
  canvas.height = rect.height * dpr;
  const ctx = canvas.getContext("2d");
  ctx.scale(dpr, dpr);
  return { ctx, w: rect.width, h: rect.height };
}

function drawAxes(ctx, pad, w, h, yMin, yMax, ySteps, xLabels, yFmt) {
  ctx.strokeStyle = themeColor("--border");
  ctx.lineWidth = 1;
  ctx.fillStyle = themeColor("--text-dim");
  ctx.font = "11px -apple-system, sans-serif";
  ctx.textAlign = "right";
  ctx.textBaseline = "middle";
  const plotW = w - pad.l - pad.r;
  const plotH = h - pad.t - pad.b;

  // y-axis gridlines & labels
  for (let i = 0; i <= ySteps; i++) {
    const v = yMin + (yMax - yMin) * (i / ySteps);
    const y = pad.t + plotH - (plotH * i / ySteps);
    ctx.beginPath();
    ctx.moveTo(pad.l, y);
    ctx.lineTo(w - pad.r, y);
    ctx.stroke();
    ctx.fillText(yFmt(v), pad.l - 6, y);
  }

  // x-axis labels (show a subset to avoid crowding)
  ctx.font = "10px -apple-system, sans-serif";
  const maxLabels = Math.floor(plotW / 36);
  const step = Math.max(1, Math.ceil(xLabels.length / maxLabels));
  xLabels.forEach((lbl, i) => {
    if (i % step !== 0 && i !== xLabels.length - 1) return;
    const x = pad.l + (plotW * i / (xLabels.length - 1 || 1));
    ctx.save();
    ctx.translate(x, h - pad.b + 6);
    ctx.rotate(-Math.PI / 4);
    ctx.textAlign = "right";
    ctx.textBaseline = "top";
    ctx.fillText(lbl, 0, 0);
    ctx.restore();
  });

  return { plotW, plotH };
}

/* ---- tooltip helper ---- */
function attachTooltip(canvas, tooltipEl, getPoints) {
  canvas.addEventListener("mousemove", e => {
    const rect = canvas.getBoundingClientRect();
    const mx = e.clientX - rect.left;
    const my = e.clientY - rect.top;
    const pts = getPoints();
    if (!pts || !pts.length) { tooltipEl.style.display = "none"; return; }

    // find nearest point by x distance
    let best = null, bestDist = Infinity;
    pts.forEach(p => {
      const d = Math.abs(mx - p.x);
      if (d < bestDist) { bestDist = d; best = p; }
    });

    if (!best || bestDist > 30) {
      tooltipEl.style.display = "none";
      return;
    }

    tooltipEl.innerHTML = best.html;
    tooltipEl.style.display = "block";
    // position relative to chart-box (the offsetParent)
    tooltipEl.style.left = best.x + 24 + "px"; // 24px = chart-box padding
    tooltipEl.style.top  = best.y + 24 + "px";
  });

  canvas.addEventListener("mouseleave", () => {
    tooltipEl.style.display = "none";
  });
}

/* ---- WAB trend line chart ---- */
let wabPoints = [];
function renderWabChart() {
  const canvas = document.getElementById("wabCanvas");
  const { ctx, w, h } = setupCanvas(canvas);

  // chronological order (GAMES is most-recent-first, reverse a copy)
  const chrono = [...GAMES].reverse();
  const vals = chrono.map(g => g._cum_wab ?? 0);
  const labels = chrono.map(g => g.opp_team_abbr || "‚Äì");

  const pad = { t: 30, r: 30, b: 55, l: 55 };
  const dataMin = Math.min(0, ...vals);
  const dataMax = Math.max(0, ...vals);
  const range = dataMax - dataMin || 1;
  const yMin = Math.floor((dataMin - range * 0.1) * 2) / 2;
  const yMax = Math.ceil((dataMax + range * 0.1) * 2) / 2;
  const ySteps = 6;

  ctx.clearRect(0, 0, w, h);
  const { plotW, plotH } = drawAxes(ctx, pad, w, h, yMin, yMax, ySteps, labels, v => v.toFixed(1));

  function yPos(v) { return pad.t + plotH - plotH * ((v - yMin) / (yMax - yMin)); }
  function xPos(i) { return pad.l + plotW * (i / (vals.length - 1 || 1)); }

  // zero line
  if (yMin < 0 && yMax > 0) {
    ctx.strokeStyle = "rgba(139,148,158,0.4)";
    ctx.setLineDash([4, 4]);
    ctx.beginPath();
    ctx.moveTo(pad.l, yPos(0));
    ctx.lineTo(w - pad.r, yPos(0));
    ctx.stroke();
    ctx.setLineDash([]);
  }

  // area fill
  ctx.beginPath();
  ctx.moveTo(xPos(0), yPos(0));
  vals.forEach((v, i) => ctx.lineTo(xPos(i), yPos(v)));
  ctx.lineTo(xPos(vals.length - 1), yPos(0));
  ctx.closePath();
  ctx.fillStyle = "rgba(88,166,255,0.10)";
  ctx.fill();

  // line
  ctx.beginPath();
  vals.forEach((v, i) => { i === 0 ? ctx.moveTo(xPos(i), yPos(v)) : ctx.lineTo(xPos(i), yPos(v)); });
  ctx.strokeStyle = themeColor("--accent");
  ctx.lineWidth = 2.5;
  ctx.lineJoin = "round";
  ctx.stroke();

  // dots & store points
  wabPoints = [];
  vals.forEach((v, i) => {
    const px = xPos(i), py = yPos(v);
    ctx.beginPath();
    ctx.arc(px, py, 3, 0, Math.PI * 2);
    ctx.fillStyle = themeColor("--accent");
    ctx.fill();

    const g = chrono[i];
    const gameWab = g.wab;
    const oe = g.OffEff_game_adj, de = g.DefEff_game_adj;
    const adjE = (oe != null && de != null) ? oe - de : null;
    const won = g.points > g.points_allowed;
    const result = `${won ? "W" : "L"} ${Math.round(g.points)}-${Math.round(g.points_allowed)}`;
    const resCls = won ? "tt-pos" : "tt-neg";

    wabPoints.push({ x: px, y: py, html:
      `<div class="tt-date">${g.date || "‚Äì"}</div>` +
      `<div><span class="tt-opp">${g.opp_team_displayName || "‚Äì"}</span> ¬∑ <span class="${resCls}">${result}</span></div>` +
      `<div>WAB: <span class="tt-val ${(gameWab ?? 0) >= 0 ? 'tt-pos' : 'tt-neg'}">${gameWab != null ? (gameWab >= 0 ? "+" : "") + gameWab.toFixed(3) : "‚Äì"}</span></div>` +
      `<div>WAB-to-Date: <span class="tt-val ${v >= 0 ? 'tt-pos' : 'tt-neg'}">${(v >= 0 ? "+" : "") + v.toFixed(1)}</span></div>` +
      `<div>Game AdjE: <span class="tt-val ${adjE != null ? (adjE >= 0 ? 'tt-pos' : 'tt-neg') : ''}">${adjE != null ? (adjE >= 0 ? "+" : "") + adjE.toFixed(1) : "‚Äì"}</span></div>`
    });
  });

  // title
  ctx.fillStyle = themeColor("--text");
  ctx.font = "bold 14px -apple-system, sans-serif";
  ctx.textAlign = "left";
  ctx.textBaseline = "top";
  ctx.fillText("Cumulative WAB Over Season", pad.l, 6);

  // attach tooltip once
  if (!canvas._ttAttached) {
    attachTooltip(canvas, document.getElementById("wabTooltip"), () => wabPoints);
    canvas._ttAttached = true;
  }
}

/* ---- AdjE vs Expected bar chart ---- */
let adjePoints = [];
function renderAdjEChart() {
  const canvas = document.getElementById("adjeCanvas");
  const { ctx, w, h } = setupCanvas(canvas);
  const HOME_ADV = 3.0;

  const chrono = [...GAMES].reverse();
  const teamNetSrs = TEAM_INFO.net_srs ?? 0;

  const vals = chrono.map(g => {
    const oe = g.OffEff_game_adj, de = g.DefEff_game_adj;
    if (oe == null || de == null) return null;
    const actualAdjE = oe - de;
    const opp = ALL_TEAMS[g.opp_team_abbr];
    const oppNetSrs = opp?.net_srs ?? 0;
    let locAdj = 0;
    if (g.homeAway === "home") locAdj = HOME_ADV;
    else if (g.homeAway === "away") locAdj = -HOME_ADV;
    const expectedAdjE = teamNetSrs - oppNetSrs + locAdj;
    return { diff: actualAdjE - expectedAdjE, actual: actualAdjE, expected: expectedAdjE };
  });

  const diffs = vals.map(v => v?.diff ?? null);
  const labels = chrono.map(g => g.opp_team_abbr || "‚Äì");

  // 5-game rolling average
  const rolling = diffs.map((v, i) => {
    const window = diffs.slice(Math.max(0, i - 4), i + 1).filter(x => x != null);
    return window.length ? window.reduce((s, x) => s + x, 0) / window.length : null;
  });

  const allVals = [...diffs, ...rolling].filter(v => v != null);
  const pad = { t: 30, r: 30, b: 55, l: 55 };
  const dataMin = Math.min(0, ...allVals);
  const dataMax = Math.max(0, ...allVals);
  const range = dataMax - dataMin || 1;
  const yMin = Math.floor((dataMin - range * 0.1) / 5) * 5;
  const yMax = Math.ceil((dataMax + range * 0.1) / 5) * 5;
  const ySteps = 6;

  ctx.clearRect(0, 0, w, h);
  const { plotW, plotH } = drawAxes(ctx, pad, w, h, yMin, yMax, ySteps, labels, v => v.toFixed(0));

  function yPos(v) { return pad.t + plotH - plotH * ((v - yMin) / (yMax - yMin)); }
  const n = diffs.length;
  const barGap = 2;
  const barW = Math.max(2, (plotW / n) - barGap);
  const zero = yPos(0);

  // bars & store points
  adjePoints = [];
  diffs.forEach((v, i) => {
    const cx = pad.l + (plotW * (i + 0.5) / n);
    if (v != null) {
      const top = v >= 0 ? yPos(v) : zero;
      const bh = Math.abs(yPos(v) - zero);
      ctx.fillStyle = v >= 0 ? "rgba(63,185,80,0.55)" : "rgba(248,81,73,0.55)";
      ctx.fillRect(cx - barW / 2, top, barW, bh);
    }

    const g = chrono[i];
    const gameWab = g.wab;
    const won = g.points > g.points_allowed;
    const result = `${won ? "W" : "L"} ${Math.round(g.points)}-${Math.round(g.points_allowed)}`;
    const resCls = won ? "tt-pos" : "tt-neg";
    const rollVal = rolling[i];
    const vObj = vals[i];

    adjePoints.push({ x: cx, y: v != null ? (v >= 0 ? yPos(v) : zero) : zero, html:
      `<div class="tt-date">${g.date || "‚Äì"}</div>` +
      `<div><span class="tt-opp">${g.opp_team_displayName || "‚Äì"}</span> ¬∑ <span class="${resCls}">${result}</span></div>` +
      `<div>Game AdjE: <span class="tt-val">${vObj ? (vObj.actual >= 0 ? "+" : "") + vObj.actual.toFixed(1) : "‚Äì"}</span></div>` +
      `<div>Expected AdjE: <span class="tt-val">${vObj ? (vObj.expected >= 0 ? "+" : "") + vObj.expected.toFixed(1) : "‚Äì"}</span></div>` +
      `<div>vs Expected: <span class="tt-val ${v != null ? (v >= 0 ? 'tt-pos' : 'tt-neg') : ''}">${v != null ? (v >= 0 ? "+" : "") + v.toFixed(1) : "‚Äì"}</span></div>` +
      `<div>5-Game Avg: <span class="tt-val">${rollVal != null ? (rollVal >= 0 ? "+" : "") + rollVal.toFixed(1) : "‚Äì"}</span></div>` +
      `<div>WAB: <span class="tt-val ${(gameWab ?? 0) >= 0 ? 'tt-pos' : 'tt-neg'}">${gameWab != null ? (gameWab >= 0 ? "+" : "") + gameWab.toFixed(3) : "‚Äì"}</span></div>`
    });
  });

  // zero line
  ctx.strokeStyle = "rgba(139,148,158,0.5)";
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(pad.l, zero);
  ctx.lineTo(w - pad.r, zero);
  ctx.stroke();

  // rolling average line
  ctx.beginPath();
  let started = false;
  rolling.forEach((v, i) => {
    if (v == null) return;
    const cx = pad.l + (plotW * (i + 0.5) / n);
    if (!started) { ctx.moveTo(cx, yPos(v)); started = true; }
    else ctx.lineTo(cx, yPos(v));
  });
  ctx.strokeStyle = themeColor("--gold");
  ctx.lineWidth = 2.5;
  ctx.lineJoin = "round";
  ctx.stroke();

  // legend
  ctx.fillStyle = themeColor("--text");
  ctx.font = "bold 14px -apple-system, sans-serif";
  ctx.textAlign = "left";
  ctx.textBaseline = "top";
  ctx.fillText("AdjE vs Expected (per game)", pad.l, 6);

  // legend items
  const legX = pad.l + 240;
  ctx.font = "12px -apple-system, sans-serif";
  ctx.fillStyle = "rgba(63,185,80,0.8)";
  ctx.fillRect(legX, 8, 12, 12);
  ctx.fillStyle = themeColor("--text-dim");
  ctx.fillText("vs Expected", legX + 16, 8);
  ctx.fillStyle = themeColor("--gold");
  ctx.fillRect(legX + 100, 12, 20, 3);
  ctx.fillStyle = themeColor("--text-dim");
  ctx.fillText("5-Game Avg", legX + 124, 8);

  // attach tooltip once
  if (!canvas._ttAttached) {
    attachTooltip(canvas, document.getElementById("adjeTooltip"), () => adjePoints);
    canvas._ttAttached = true;
  }
}

/* ---- Seed-by-Losses simulation chart ---- */
let simPoints = [];
function renderSimChart() {
  const canvas = document.getElementById("simCanvas");
  if (!SIM_TEAM) {
    const { ctx, w, h } = setupCanvas(canvas);
    ctx.clearRect(0, 0, w, h);
    ctx.fillStyle = themeColor("--text-dim");
    ctx.font = "14px -apple-system, sans-serif";
    ctx.textAlign = "center";
    ctx.fillText("No simulation data available", w / 2, h / 2);
    return;
  }

  const sbl = SIM_TEAM.seed_by_losses || [];
  if (sbl.length === 0) {
    const { ctx, w, h } = setupCanvas(canvas);
    ctx.clearRect(0, 0, w, h);
    ctx.fillStyle = themeColor("--text-dim");
    ctx.font = "14px -apple-system, sans-serif";
    ctx.textAlign = "center";
    ctx.fillText("No remaining games to simulate", w / 2, h / 2);
    return;
  }

  /* Hide chart for teams with negligible tournament odds (< 0.5%) */
  if ((SIM_TEAM.make_pct || 0) < 0.5) {
    const { ctx, w, h } = setupCanvas(canvas);
    ctx.clearRect(0, 0, w, h);
    ctx.fillStyle = themeColor("--text-dim");
    ctx.font = "14px -apple-system, sans-serif";
    ctx.textAlign = "center";
    ctx.fillText("Tournament odds too low to project seeds", w / 2, h / 2);
    return;
  }

  const { ctx, w, h } = setupCanvas(canvas);
  ctx.clearRect(0, 0, w, h);

  // Filter to buckets that have sims
  const buckets = sbl.filter(b => b.sims > 0);
  const losses = buckets.map(b => b.losses);
  const makePcts = buckets.map(b => b.make_pct);
  const avgSeeds = buckets.map(b => b.avg_seed);

  // Determine if we have meaningful seed data (at least some with avg_seed)
  const hasSeedData = avgSeeds.some(v => v != null);

  const pad = { t: 36, r: 60, b: 50, l: 55 };
  const plotW = w - pad.l - pad.r;
  const plotH = h - pad.t - pad.b;

  // Seed y-axis (inverted: 1 at top, max at bottom)
  const seedVals = avgSeeds.filter(v => v != null);
  let seedMin = 1;
  let seedMax = 16;
  if (seedVals.length > 0) {
    seedMax = Math.min(16, Math.ceil(Math.max(...seedVals) + 1));
    seedMin = Math.max(1, Math.floor(Math.min(...seedVals) - 0.5));
  }

  function xPos(i) { return pad.l + plotW * (i / Math.max(losses.length - 1, 1)); }
  // seed axis: inverted (lower seed number = better = higher on chart)
  function ySeed(v) { return pad.t + plotH * ((v - seedMin) / (seedMax - seedMin)); }
  // make% axis: 0 at bottom, 100 at top
  function yMake(v) { return pad.t + plotH - plotH * (v / 100); }

  // ---- Grid lines for seed axis ----
  ctx.strokeStyle = themeColor("--border");
  ctx.lineWidth = 1;
  ctx.fillStyle = themeColor("--text-dim");
  ctx.font = "11px -apple-system, sans-serif";
  ctx.textAlign = "right";
  ctx.textBaseline = "middle";

  const seedStep = seedMax - seedMin <= 8 ? 1 : 2;
  for (let s = seedMin; s <= seedMax; s += seedStep) {
    const y = ySeed(s);
    ctx.beginPath();
    ctx.moveTo(pad.l, y);
    ctx.lineTo(w - pad.r, y);
    ctx.stroke();
    ctx.fillText(s.toString(), pad.l - 6, y);
  }

  // ---- Right axis labels for Make% ----
  ctx.textAlign = "left";
  for (let p = 0; p <= 100; p += 25) {
    const y = yMake(p);
    ctx.fillText(p + "%", w - pad.r + 6, y);
  }

  // ---- X-axis labels (# of losses) ----
  ctx.textAlign = "center";
  ctx.textBaseline = "top";
  buckets.forEach((b, i) => {
    ctx.fillText(b.losses.toString(), xPos(i), pad.t + plotH + 8);
  });
  ctx.fillText("Remaining Losses", pad.l + plotW / 2, pad.t + plotH + 28);

  // ---- Y-axis titles ----
  ctx.save();
  ctx.translate(14, pad.t + plotH / 2);
  ctx.rotate(-Math.PI / 2);
  ctx.textAlign = "center";
  ctx.textBaseline = "top";
  ctx.fillStyle = themeColor("--accent");
  ctx.font = "bold 11px -apple-system, sans-serif";
  ctx.fillText("Projected Seed", 0, 0);
  ctx.restore();

  ctx.save();
  ctx.translate(w - 8, pad.t + plotH / 2);
  ctx.rotate(Math.PI / 2);
  ctx.textAlign = "center";
  ctx.textBaseline = "top";
  ctx.fillStyle = themeColor("--green");
  ctx.font = "bold 11px -apple-system, sans-serif";
  ctx.fillText("Make %", 0, 0);
  ctx.restore();

  // ---- Make% area fill + line ----
  ctx.beginPath();
  ctx.moveTo(xPos(0), yMake(0));
  buckets.forEach((b, i) => ctx.lineTo(xPos(i), yMake(b.make_pct)));
  ctx.lineTo(xPos(buckets.length - 1), yMake(0));
  ctx.closePath();
  ctx.fillStyle = "rgba(63,185,80,0.08)";
  ctx.fill();

  ctx.beginPath();
  buckets.forEach((b, i) => {
    const px = xPos(i), py = yMake(b.make_pct);
    i === 0 ? ctx.moveTo(px, py) : ctx.lineTo(px, py);
  });
  ctx.strokeStyle = "rgba(63,185,80,0.6)";
  ctx.lineWidth = 2;
  ctx.setLineDash([6, 3]);
  ctx.stroke();
  ctx.setLineDash([]);

  // ---- Avg Seed line (only where avg_seed is non-null) ----
  if (hasSeedData) {
    // draw the line
    ctx.beginPath();
    let started = false;
    buckets.forEach((b, i) => {
      if (b.avg_seed == null) return;
      const px = xPos(i), py = ySeed(b.avg_seed);
      if (!started) { ctx.moveTo(px, py); started = true; }
      else ctx.lineTo(px, py);
    });
    ctx.strokeStyle = themeColor("--accent");
    ctx.lineWidth = 3;
    ctx.lineJoin = "round";
    ctx.stroke();

    // dots
    buckets.forEach((b, i) => {
      if (b.avg_seed == null) return;
      const px = xPos(i), py = ySeed(b.avg_seed);
      ctx.beginPath();
      ctx.arc(px, py, 5, 0, Math.PI * 2);
      ctx.fillStyle = themeColor("--accent");
      ctx.fill();
      ctx.strokeStyle = themeColor("--bg");
      ctx.lineWidth = 2;
      ctx.stroke();
    });
  }

  // ---- Make% dots on dashed line ----
  buckets.forEach((b, i) => {
    const px = xPos(i), py = yMake(b.make_pct);
    ctx.beginPath();
    ctx.arc(px, py, 4, 0, Math.PI * 2);
    ctx.fillStyle = themeColor("--green");
    ctx.fill();
    ctx.strokeStyle = themeColor("--bg");
    ctx.lineWidth = 1.5;
    ctx.stroke();
  });

  // ---- Tooltip points ----
  simPoints = [];
  buckets.forEach((b, i) => {
    const px = xPos(i);
    const py = b.avg_seed != null ? ySeed(b.avg_seed) : yMake(b.make_pct);
    const seedStr = b.avg_seed != null ? b.avg_seed.toFixed(1) : "‚Äî";
    const makeStr = b.make_pct.toFixed(1) + "%";
    const simsPct = SIM_TEAM.remaining_games > 0
      ? ` (${(100 * b.sims / (sbl.reduce((s, x) => s + x.sims, 0))).toFixed(1)}% of sims)`
      : "";

    simPoints.push({ x: px, y: py, html:
      `<div style="font-weight:700;color:var(--accent)">${b.losses} remaining loss${b.losses !== 1 ? "es" : ""}</div>` +
      `<div>Avg Seed: <span class="tt-val" style="color:#58a6ff">${seedStr}</span></div>` +
      `<div>Make Tourn: <span class="tt-val" style="color:#3fb950">${makeStr}</span></div>` +
      `<div style="color:var(--text-dim);font-size:.72rem">${b.sims.toLocaleString()} sims${simsPct}</div>`
    });
  });

  // ---- Title ----
  ctx.fillStyle = themeColor("--text");
  ctx.font = "bold 14px -apple-system, sans-serif";
  ctx.textAlign = "left";
  ctx.textBaseline = "top";
  ctx.fillText("Projected Seed by Remaining Losses", pad.l, 6);

  // ---- Legend ----
  const legX = pad.l + 280;
  ctx.font = "12px -apple-system, sans-serif";
  // seed line legend
  ctx.strokeStyle = themeColor("--accent");
  ctx.lineWidth = 3;
  ctx.beginPath();
  ctx.moveTo(legX, 14);
  ctx.lineTo(legX + 20, 14);
  ctx.stroke();
  ctx.beginPath();
  ctx.arc(legX + 10, 14, 3, 0, Math.PI * 2);
  ctx.fillStyle = themeColor("--accent");
  ctx.fill();
  ctx.fillStyle = themeColor("--text-dim");
  ctx.textAlign = "left";
  ctx.textBaseline = "middle";
  ctx.fillText("Avg Seed", legX + 26, 14);
  // make% legend
  const legX2 = legX + 100;
  ctx.strokeStyle = "rgba(63,185,80,0.6)";
  ctx.lineWidth = 2;
  ctx.setLineDash([6, 3]);
  ctx.beginPath();
  ctx.moveTo(legX2, 14);
  ctx.lineTo(legX2 + 20, 14);
  ctx.stroke();
  ctx.setLineDash([]);
  ctx.beginPath();
  ctx.arc(legX2 + 10, 14, 3, 0, Math.PI * 2);
  ctx.fillStyle = themeColor("--green");
  ctx.fill();
  ctx.fillStyle = themeColor("--text-dim");
  ctx.fillText("Make %", legX2 + 26, 14);

  // attach tooltip once
  if (!canvas._ttAttached) {
    attachTooltip(canvas, document.getElementById("simTooltip"), () => simPoints);
    canvas._ttAttached = true;
  }
}
</script>
</body>
</html>
